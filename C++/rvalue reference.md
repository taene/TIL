## 학습 키워드
- `lvalue, rvalue`
- `우측값 참조(rvalue reference)`
- `이동 시맨틱스(move semantics)`
- `완벽한 전달(perfect forwarding)`
- `std::move`
- `std::forward`
- `noexcept`

## 학습 내용
### 배운 개념 요약
- **좌측값(lvalue) vs. 우측값(rvalue)**
    - **좌측값(lvalue)**: 메모리 위치를 가리키며 `&` 연산자로 주소를 얻을 수 있는 표현식이다. (변수 등이 대표적)
    - **우측값(rvalue)**: 좌측값이 아닌 모든 값으로, 주로 임시적인 값이다. 리터럴 `42`나 `int`를 반환하는 함수 호출 결과 등이 해당한다.

- **우측값 참조 (`&&`)**
    - C++11 표준에 추가된 개념으로, 이동 시맨틱스와 완벽한 전달 문제를 해결하기 위해 도입되었다.
    - 함수 오버로딩 시 우측값을 인자로 받는 함수(`void foo(X&&)`)가 우측값을 우선적으로 처리하게 해준다.

- **이동 시맨틱스 (Move Semantics)**
    - 임시 객체의 리소스를 비효율적으로 복사하는 대신, 리소스 소유권을 '이동'시켜 성능을 향상시키는 기법이다.
    - 이동 생성자(`X(X&&)`)와 이동 대입 연산자(`X& operator=(X&&)`)를 오버로딩하여 구현한다.

- **`std::move`**
    - 인자로 받은 값을 우측값으로 변환(캐스팅)하는 표준 라이브러리 함수다.
    - 좌측값에 대해 강제로 이동 연산을 적용하고 싶을 때 사용한다.
    - 주의: `std::move`로 이동된 객체의 리소스는 비워질 수 있으므로, 이후에 다시 사용하지 않는 것이 안전하다. 또한, 함수 내 지역 변수를 반환할 때 `return std::move(x);`를 사용하면 컴파일러의 '반환 값 최적화(RVO)'를 방해할 수 있다.

- **가장 중요한 규칙: "이름이 있으면 좌측값"**
    - 우측값 참조 타입(`X&& x`)으로 선언된 변수라도, `x`라는 **이름을 가지고 있기 때문에 그 자체는 좌측값(lvalue)으로 취급된다**.
    - 이 규칙 때문에, 이동 생성자 등에서 인자로 받은 `rhs`를 다른 함수(예: 부모 클래스의 이동 생성자)에 넘길 때는 `std::move(rhs)`와 같이 다시 한번 명시적으로 이동시켜야 한다.

- **완벽한 전달 (Perfect Forwarding)과 `std::forward`**
    - 함수 템플릿이 인자를 다른 함수로 전달할 때, 인자의 원래 속성(좌측값/우측값)을 그대로 유지하는 기능이다.
    - `std::forward`는 전달받은 인자가 이름 때문에 좌측값으로 취급되는 것을 막고, 원래의 값 속성을 보존하여 전달하는 역할을 한다.

- **`noexcept` 키워드**
    - 이동 생성자와 이동 대입 연산자는 예외를 던지지 않도록 구현하고, 이를 `noexcept` 키워드로 명시하는 것이 강력히 권장된다.
    - `noexcept`로 명시하지 않으면 `std::vector`와 같은 컨테이너가 안전을 위해 이동 대신 복사를 수행할 수 있어 성능 저하의 원인이 된다.

### 구현 과정
1.  **이동 연산자 구현**: 리소스를 관리하는 클래스에 이동 생성자(`ClassName(ClassName&& rhs)`)와 이동 대입 연산자(`operator=(ClassName&& rhs)`)를 정의한다.
2.  **`noexcept` 명시**: 정의된 이동 연산자 함수 뒤에 `noexcept` 키워드를 붙여 예외를 던지지 않음을 명시한다.
3.  **`std::move`로 호출**: 좌측값 객체를 이동시키고 싶을 때 `ClassName b = std::move(a);`와 같이 사용하여 이동 연산을 강제로 호출한다.
4.  **완벽한 전달 구현**: 템플릿 함수에서 인자를 `Arg&& arg`와 같이 받고, 다른 함수로 전달 시 `std::forward<Arg>(arg)`를 사용한다.

## 느낀점
- 우측값 참조는 '불필요한 복사를 피한다'는 명확한 목적을 이해했다.
- **"이름이 있는 우측값 참조는 좌측값이다"** 라는 규칙이 가장 핵심적이고 헷갈리는 부분이었다. 이 규칙을 이해하는 것이 `std::move`를 올바르게 사용하는 열쇠라는 것을 깨달았다.
- `std::move`는 이름 그대로 무언가를 '이동'시키는 함수가 아니라, 단지 우측값으로 '캐스팅'해주는 역할이라는 점이 명확해졌다. 실제 이동은 그 결과로 호출되는 이동 연산자의 몫이다.
- `noexcept`가 컴파일러의 최적화 동작에 직접적인 영향을 미치는 중요한 키워드라는 사실이 인상 깊었다. C++ 성능을 제대로 끌어내려면 반드시 고려해야 할 부분이다.
