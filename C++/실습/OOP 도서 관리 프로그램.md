# [Project] C++ 객체지향 도서 관리 프로그램

## 학습 키워드
- C++ 객체지향 프로그래밍 (OOP)
- 클래스 설계 원칙 (SOLID)
- 응집도(Cohesion)와 결합도(Coupling)
- 책임 분리 원칙 (Separation of Concerns)
- `const` 멤버 함수 (const-correctness)
- `std::unordered_map`과 사용자 정의 키(Key)
- `static` 멤버 함수

<br/>

## 학습 내용
### 배운 개념 요약
- **`const` 멤버 함수**: 함수 뒤에 `const`를 붙이면 해당 함수는 '읽기 전용' 모드로 동작하며, 클래스의 어떤 멤버 변수도 수정하지 않겠다고 컴파일러에 약속하는 것이다. `const` 멤버 함수 내에서는 멤버 변수들도 `const`로 취급되므로, 해당 멤버 변수들이 호출하는 함수 역시 `const` 멤버 함수여야 한다. 이는 코드의 안정성을 높이는 중요한 `const-correctness` 원칙이다.

- **`unordered_map`과 사용자 정의 키**: `std::unordered_map`의 키(Key)로 사용자 정의 클래스(ex. class Book)를 사용하려면, 컴파일러에게 **1) 해당 클래스를 해시(hash)하는 방법**과 **2) 두 객체가 같은지 비교하는(`operator==`) 방법**을 반드시 제공해야 한다. 그렇지 않으면 컴파일 오류가 발생한다. 대부분의 경우, 객체 내부의 고유한 `string`이나 `int` 값을 키로 사용하는 것이 더 간단하고 효율적이다.

- **클래스 설계 (응집도와 결합도)**: 좋은 객체지향 설계는 **높은 응집도**와 **느슨한 결합도**를 지향한다.
    - **높은 응집도 (High Cohesion)**: 하나의 클래스는 하나의 명확한 책임만 갖도록 기능을 집중시키는 것이다.
    - **느슨한 결합도 (Loose Coupling)**: 클래스 간의 의존성을 최소화하여, 한 클래스의 변경이 다른 클래스에 미치는 영향을 줄이는 것이다. 클래스끼리 협력할 때는 상대방의 내부 구현을 알 필요 없이, 공개된 인터페이스(public 메서드)를 통해서만 소통해야 한다.
      - 반대로 강한 결합은 한 클래스를 바꾸면 다른 클래스도 반드시 함께 바꿔야하는 수준이다.

<br/>

### 구현 과정
- **초기 설계의 문제점**: 처음에는 도서 목록을 관리하는 `BookManager`와 재고를 관리하는 `BorrowManager`가 있었지만, 두 클래스는 서로의 존재를 모른 채 독립적으로 동작했다. 이로 인해 `BookManager`에 책을 추가해도 `BorrowManager`의 재고에는 반영되지 않는 등 논리적 허점이 존재했다.

- **1차 개선 (책임 분리 및 구조화)**: `BookManager`가 `BorrowManager`를 멤버 변수로 소유하는 **Composition(포함)** 관계로 구조를 변경했다.
    - **`BookManager`**: "총괄 매니저" 역할. 외부의 모든 요청을 받고, 도서 목록을 관리하며, 실제 재고 처리는 `BorrowManager`에게 위임한다.
    - **`BorrowManager`**: "재고 관리 실무자" 역할. 재고와 관련된 구체적인 로직을 전담하며, 자신의 내부 구현은 `BookManager`에게 숨긴다(캡슐화).
    - 이 구조를 통해 **요청의 흐름을 단방향**으로 만들고, 각 클래스의 책임을 명확히 하여 **높은 응집도와 느슨한 결합도**를 달성했다.

- **오류 수정 및 개념 확립**:
    1. `BorrowManager`에서 `unordered_map`의 키를 `Book` 객체에서 `string` 타입의 책 제목으로 변경하여 컴파일 오류를 해결했다.
    2. `BookManager::displayAllBooks`를 `const` 멤버 함수로 만들면서, 이 함수가 호출하는 `BorrowManager::isAvailable` 또한 `const`로 선언해야 한다는 `const-correctness` 원칙을 적용했다.
    3. 객체의 멤버 변수에 접근해야 하는 `findBookByTitle` 함수에서 `static` 키워드를 제거하며, `static` 멤버 함수와 일반 멤버 함수의 차이점을 명확히 이해했다.

<br/>

## 느낀점
- 단순히 기능이 동작하는 코드를 짜는 것과, **객체지향 원칙에 따라 '잘 설계된' 코드를 짜는 것**은 완전히 다른 차원임을 깨달았다. 클래스의 책임을 명확히 나누는 것이 왜 중요한지 체감할 수 있었다.

- `const` 키워드는 단순히 값을 바꾸지 못하게 막는 제약 조건이 아니라, **함수의 의도(읽기 전용)를 명확히 하고 컴파일 타임에 실수를 방지해 주는 매우 강력한 설계 도구**라는 것을 배웠다. 앞으로는 `const`를 적극적으로 활용하여 더 안정적인 코드를 작성해야겠다.

- 좋은 설계(높은 응집도, 느슨한 결합도)는 당장의 코드 몇 줄을 줄여주진 않지만, **미래에 발생할 수 있는 버그를 예방하고 기능 확장 및 유지보수를 훨씬 쉽게 만들어 준다.** 각 클래스를 독립적인 부품처럼 만들어, 필요할 때 쉽게 교체하거나 재사용할 수 있는 구조의 중요성을 느꼈다.
