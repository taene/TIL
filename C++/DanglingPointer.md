## Dangling Pointer
- **λ•κΈ€λ§ ν¬μΈν„°**: μ΄λ―Έ ν•΄μ λμ—κ±°λ‚ λ”μ΄μƒ μ ν¨ν•μ§€ μ•μ€ λ©”λ¨λ¦¬ μ„μΉλ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
- dangling: λ§¤λ‹¬λ ¤μλ”, λ¶μ•μ •ν•(ν—κ³µμ— λ§¤λ‹¬λ ¤ μλ” κ²ƒμ²λΌ μ„ν—ν• μƒνƒμ ν¬μΈν„°)

<br/>

### β οΈ μ‹¬κ°ν• λ¬Έμ  λ°μƒ μμ‹
1. ν”„λ΅κ·Έλ¨ λΉ„μ •μƒ μΆ…λ£(Crash): μ΄μμ²΄μ κ°€ λ³΄νΈλ λ©”λ¨λ¦¬ μμ—­μ— μ ‘κ·Όν•λ ¤λ” μ‹λ„λ¥Ό κ°μ§€ν•κ³  ν”„λ΅κ·Έλ¨μ„ κ°•μ  μΆ…λ£μ‹ν‚΄.(Segmentation Fault)
2. λ°μ΄ν„° μ†μƒ(Data Corruption): Dangling Pointerκ°€ κ°€λ¦¬ν‚¤λ” λ©”λ¨λ¦¬ μ„μΉμ— λ‹¤λ¥Έ λ°μ΄ν„°κ°€ μ΄λ―Έ ν• λ‹Ήλμ—μ„ μ μκΈ° λ•λ¬Έμ—, μ΄λ¥Ό ν†µν•΄ κ°’μ„ μ“°λ ¤κ³  ν•λ©΄ μ—‰λ±ν• λ°μ΄ν„°λ¥Ό λ®μ–΄μ“°κ² λΌ ν”„λ΅κ·Έλ¨ μ „μ²΄μ λ°μ΄ν„°κ°€ λ§κ°€μ§ μ μμ
3. μμΈ΅ λ¶κ°€λ¥ν• λ™μ‘(Undefined Behavior): μ»΄νμΌλ¬λ‚ μ‹¤ν–‰ ν™κ²½μ— λ”°λΌ λ™μ‘μ΄ λ‹¬λΌμ§ μ μμ(λ””λ²„κΉ…μ΄ μ–΄λ ¤μ›μ§)
4. λ³΄μ• μ·¨μ•½μ : μ•…μμ μΈ μ‚¬μ©μκ°€ Dangling pointerλ¥Ό μ΄μ©ν•΄ ν”„λ΅κ·Έλ¨μ μ μ–΄ νλ¦„μ„ λ°”κΎΈκ±°λ‚ λ―Όκ°ν• μ •λ³΄μ— μ ‘κ·Όν•  μ μμ

<br/>

### π” λ°μƒ μ›μΈ
#### 1. λ©”λ¨λ¦¬ ν•΄μ  ν›„ μ ‘κ·Ό(Deallocation)
```cpp
#include <iostream>

int main()
{
    int* ptr = new int(10); // λ™μ  λ©”λ¨λ¦¬ ν• λ‹Ή
    std::cout << "ptrμ΄ κ°€λ¦¬ν‚¤λ” κ°’: " << *ptr << std::endl; // μ •μƒ: 10

    delete ptr; // λ©”λ¨λ¦¬ ν•΄μ 
    // μ΄μ  ptrμ€ λ•κΈ€λ§ ν¬μΈν„°κ°€ λλ‹¤!

    // std::cout << "ν•΄μ  ν›„ ptrμ΄ κ°€λ¦¬ν‚¤λ” κ°’: " << *ptr << std::endl; // λ§¤μ° μ„ν—! λ•κΈ€λ§ ν¬μΈν„° μ—­μ°Έμ΅° (Undefined Behavior)
    // *ptr = 20; // λ” μ„ν—! μ΄λ―Έ ν•΄μ λ λ©”λ¨λ¦¬μ— κ°’μ„ μ“°λ ¤κ³  μ‹λ„

    // μΆ‹μ€ μµκ΄€: ν•΄μ  ν›„μ—λ” nullptrλ΅ μ΄κΈ°ν™”
    ptr = nullptr;

    if (ptr != nullptr) {
        std::cout << "nullptrμ΄ μ•„λ‹λΌλ©΄ ptrμ΄ κ°€λ¦¬ν‚¤λ” κ°’: " << *ptr << std::endl;
    } else {
        std::cout << "ptrμ€ nullptrμ…λ‹λ‹¤." << std::endl;
    }

    return 0;
}
```
- deleteλ΅ λ™μ  ν• λ‹Ή λ©”λ¨λ¦¬λ¥Ό ν•΄μ ν• λ’¤, ν•΄λ‹Ή λ©”λ¨λ¦¬λ¥Ό κ°€λ¦¬ν‚¤λ ν¬μΈν„°λ¥Ό λ‹¤μ‹ μ‚¬μ©ν•λ ¤κ³  ν•  λ• λ°μƒν•¨

#### 2. ν•¨μ λ°ν™ κ°’(Returning Local Variable's Address)
```cpp
#include <iostream>

int* createInteger()
{
    int localVar = 100;
    // return &localVar; // λ§¤μ° μ„ν—! μ§€μ—­ λ³€μμ μ£Όμ†λ¥Ό λ°ν™ν•λ©΄ μ• λλ‹¤.
                       // ν•¨μκ°€ μΆ…λ£λλ©΄ localVarμ€ μ‚¬λΌμ§€κ³ , λ°ν™λ ν¬μΈν„°λ” λ•κΈ€λ§ ν¬μΈν„°κ°€ λλ‹¤.
    int* heapVar = new int(100); // λ™μ  ν• λ‹Ήλ λ©”λ¨λ¦¬λ” ν•¨μκ°€ λλ‚λ„ μ μ§€λλ‹¤.
    return heapVar; // μ΄ κ²½μ°λ” κ΄μ°®μ§€λ§, νΈμ¶ν• μ½μ—μ„ deleteλ¥Ό μ±…μ„μ Έμ•Ό ν•λ‹¤.
}

int main()
{
    int* danglingPtr = createInteger(); // λ§μ•½ createIntegerκ°€ μ§€μ—­ λ³€μ μ£Όμ†λ¥Ό λ°ν™ν–λ‹¤λ©΄, μ—¬κΈ°μ„ danglingPtrμ€ λ•κΈ€λ§ ν¬μΈν„°.

    // std::cout << "λ•κΈ€λ§ ν¬μΈν„°κ°€ κ°€λ¦¬ν‚¤λ” κ°’: " << *danglingPtr << std::endl; // μ„ν—!
    
    // createIntegerκ°€ λ™μ  ν• λ‹Ήλ λ©”λ¨λ¦¬μ μ£Όμ†λ¥Ό λ°ν™ν–λ‹¤λ©΄ μ•„λμ²λΌ μ‚¬μ©ν•κ³  ν•΄μ ν•΄μ•Ό ν•λ‹¤.
    if (danglingPtr != nullptr) {
        std::cout << "λ™μ  ν• λ‹Ήλ λ³€μμ κ°’: " << *danglingPtr << std::endl;
        delete danglingPtr; // λ©”λ¨λ¦¬ ν•΄μ 
        danglingPtr = nullptr;
    }
    
    return 0;
}
```
- ν•¨μ λ‚΄λ¶€μ— μ„ μ–Έλ μ§€μ—­ λ³€μμ μ£Όμ†λ¥Ό λ°ν™ν•  λ•, ν•¨μκ°€ μΆ…λ£λλ©΄ μ§€μ—­ λ³€μλ” μ¤νƒμ—μ„ μ‚¬λΌμ§€λ”λ° μ΄λ• λ°ν™λ ν¬μΈν„°λ” μ΄λ―Έ μ‚¬λΌμ§„ λ©”λ¨λ¦¬ μ„μΉλ¥Ό κ°€λ¦¬ν‚¤κ² λ¨

#### 3. ν¬μΈν„°μ μ ν¨ λ²”μ„(Scope)
```cpp
#include <iostream>

int main() {
    int* p1 = new int(50);
    int* p2 = p1; // p1κ³Ό p2λ” κ°™μ€ λ©”λ¨λ¦¬λ¥Ό κ°€λ¦¬ν‚¨λ‹¤.

    std::cout << "p1: " << *p1 << ", p2: " << *p2 << std::endl;

    delete p1; // p1μ΄ κ°€λ¦¬ν‚¤λ” λ©”λ¨λ¦¬ ν•΄μ 
    p1 = nullptr;

    // μ΄μ  p2λ” λ•κΈ€λ§ ν¬μΈν„°κ°€ λλ‹¤!
    // std::cout << "ν•΄μ  ν›„ p2: " << *p2 << std::endl; // μ„ν—!

    return 0;
}
```
- ν¬μΈν„° λ³€μ μμ²΄κ°€ μ ν¨ λ²”μ„λ¥Ό λ²—μ–΄λ‚λ” κ²½μ°μ™€λ” λ‹¤λ¥Έ κ°λ…μ„
- μ—¬λ¬ ν¬μΈν„°κ°€ κ°™μ€ λ©”λ¨λ¦¬λ¥Ό κ°€λ¦¬ν‚¤κ³  μμ„ λ• ν•λ‚μ ν¬μΈν„°λ΅ λ©”λ¨λ¦¬λ¥Ό ν•΄μ ν•λ©΄ λ‹¤λ¥Έ ν¬μΈν„°λ“¤μ΄ λ•κΈ€λ§ ν¬μΈν„°κ°€ λ  μ μμ

<br/>

### λ•κΈ€λ§ ν¬μΈν„° νν”Όμ™€ κ΄€λ¦¬ λ°©λ²•
#### 1. ν•΄μ  ν›„ nullptr ν• λ‹Ή
```cpp
int* ptr = new int(10);
// ... ptr μ‚¬μ© ...
delete ptr;
ptr = nullptr; // μ΄μ  ptrμ€ λ•κΈ€λ§ ν¬μΈν„°κ°€ μ•„λ‹λ‹¤!
```

#### 2. μ¤λ§νΈ ν¬μΈν„° ν™μ© β¨π‘
- μ¤λ§νΈ ν¬μΈν„°: κ°μ²΄κ°€ μ†λ©Έλ  λ• μμ‹ μ΄ κ°€λ¦¬ν‚¤λ” λ©”λ¨λ¦¬λ¥Ό μλ™μΌλ΅ ν•΄μ ν•΄μ£Όλ” κΈ°λ¥μ„ κ°€μ§(RAII ν¨ν„΄)
- std::unique_ptr: νΉμ • κ°μ²΄μ— λ€ν• μ μΌν• μ†μ κ¶μ„ κ°€μ§
  - unique_ptrμ΄ μ†λ©Έλλ©΄ κ°€λ¦¬ν‚¤λ κ°μ²΄λ„ μλ™μΌλ΅ μ‚­μ λ¨
  - λ³µμ‚¬ λ¶κ°€λ¥, μ΄λ™λ§ κ°€λ¥ => μ†μ κ¶ κ΄€λ¦¬ λ…ν™•ν•¨
- std::shared_ptr: μ°Έμ΅° μΉ΄μ΄ν…(reference counting) λ°©μ‹μ„ μ‚¬μ©ν•΄ μ—¬λ¬ shared_ptrμ΄ ν•λ‚μ κ°μ²΄λ¥Ό κ³µμ ν•  μ μκ² ν•¨
  - κ°μ²΄λ¥Ό κ°€λ¦¬ν‚¤λ” shared_ptrμ μκ°€ 0μ΄ λλ©΄ κ°μ²΄κ°€ μλ™μΌλ΅ μ‚­μ λ¨
  - μν™ μ°Έμ΅°(circular dependency) λ¬Έμ λ¥Ό μ΅°μ‹¬ν•΄μ•Ό ν•¨
- std::weak_ptr: shared_ptrκ³Ό ν•¨κ» μ‚¬μ©λλ©°, shared_ptrμ΄ κ΄€λ¦¬ν•λ” κ°μ²΄λ¥Ό κ°€λ¦¬ν‚¤μ§€λ§ μ†μ κ¶μ„ κ°€μ§€μ§€ μ•μ(μ°Έμ΅° μΉ΄μ΄νΈμ— μν–¥ x)
  - shared_ptrμ μν™ μ°Έμ΅° λ¬Έμ λ¥Ό ν•΄κ²°ν•λ”λ° λ„μ›€μ„ μ¤
  - κ°μ²΄μ μ ν¨μ„±μ„ μ•μ „ν•κ² ν™•μΈν•  λ• μ‚¬μ©λ¨(lock() ν•¨μλ¥Ό ν†µν•΄ μ ν¨ν• shared_ptrλ¥Ό μ–»μ„ μ μμ)
- Unreal Engine Smart Pointer: <tt>TSharedPtr</tt>, <tt>TUniquePtr</tt>, <tt>TWeakPtr</tt>

#### 3. μ†μ κ¶(Ownership) λ…ν™•ν ν•κΈ°
- ν¬μΈν„°κ°€ κ°€λ¦¬ν‚¤λ” λ©”λ¨λ¦¬μ— λ€ν• μ†μ κ¶μ„ λ„κ°€ κ°–λ”μ§€ λ…ν™•ν μ„¤κ³„ν•λ” κ²ƒμ΄ μ¤‘μ”ν•¨
- ν•­μƒ "λ„κ°€ μ΄ λ©”λ¨λ¦¬λ¥Ό ν•΄μ ν•  μ±…μ„μ΄ μλ”κ°€?"λ¥Ό κ³ λ―Όν•  κ²ƒ
- μ΄ λ¬Έμ  λν• μ¤λ§νΈ ν¬μΈν„°λ¥Ό ν™μ©ν•λ©΄ ν•΄κ²°κ°€λ¥

#### 4. RAII(Resource Acquisition Is Initialization) ν¨ν„΄ ν™μ©
- "μμ› νλ“μ€ μ΄κΈ°ν™”λ‹¤" λΌλ” λ»
- κ°μ²΄κ°€ μƒμ„±λ  λ• μμ›μ„ νλ“ν•κ³  κ°μ²΄κ°€ μ†λ©Έλ  λ• μμ›μ„ ν•΄μ ν•λ” λ””μμΈ ν¨ν„΄(λ€ν‘μ  μμ‹: μ¤λ§νΈ ν¬μΈν„°)

<br/>

### μ–Έλ¦¬μ–Ό μ—”μ§„μ—μ„μ Dangling Pointer
- μμ²΄ **Garbage Collection**μ΄ μμ
  - UObjectμ— λ€ν•΄μ„λ” deleteλ¥Ό μ§μ ‘ νΈμ¶ν•  ν•„μ”μ—†μ΄, λ”μ΄μƒ μ°Έμ΅°λμ§€ μ•λ” UObjectλ“¤μ„ λ©”λ¨λ¦¬μ—μ„ ν•΄μ ν•΄μ¤
- β οΈ UObjectκ°€ μ•„λ‹ μΌλ° C++ κ°μ²΄λ‚ λ™μ  ν• λ‹Ήλ λ°μ΄ν„°μ— λ€ν•΄μ„λ” μ—¬μ „ν C++ λ©”λ¨λ¦¬ κ΄€λ¦¬ κ·μΉ™μ„ λ”°λΌμ•Ό ν•¨!
- <tt>TSharedPtr</tt>, <tt>TUniquePtr</tt>, <tt>TWeakPtr</tt>: UObjectκ°€ GCμ— μν•΄ ν•΄μ λ  κ°€λ¥μ„±μ΄ μμ„ λ•, TWeakPtrλ¥Ό μ‚¬μ©ν•λ©΄ ν•΄λ‹Ή κ°μ²΄κ°€ μ•„μ§ μ ν¨ν•μ§€ ν™•μΈν•κ³  (IsValid()), μ ‘κ·Όν•  μ μμ

<br/>
