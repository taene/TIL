## 학습 키워드
  - C++ 템플릿 (`template <typename T>`)
  - 동적 배열 (Dynamic Array)
  - 동적 메모리 할당 (`new[]`, `delete[]`)
  - 생성자 (Constructor) 및 소멸자 (Destructor)
  - 복사 생성자 (Copy Constructor)와 깊은 복사 (Deep Copy)
  - 선택 정렬 (Selection Sort) 알고리즘
  - RAII (Resource Acquisition Is Initialization) 패턴

<br/>

## 학습 내용

### 배운 개념 요약

  - **`std::vector`와 유사한 동적 배열 클래스 `SimpleVector`를 직접 구현**하며 내부 동작 원리를 학습했다. 사용자가 어떤 타입의 데이터(`int`, `float`, `UObject*` 등)라도 담을 수 있도록 **클래스 템플릿**을 활용하여 범용성을 높였다.

  - **동적 메모리 관리**의 핵심인 `new[]`와 `delete[]`를 사용해 힙(Heap) 메모리에 데이터를 저장하고 해제하는 방법을 익혔다. 특히, 클래스의 **생성자**에서 자원(메모리)을 할당하고 **소멸자**에서 해제하는 **RAII 패턴**을 적용하여 메모리 누수를 방지하는 방법을 체득했다.

  - 포인터 멤버 변수(`T* data`)를 가진 클래스에서 **깊은 복사(Deep Copy)**의 중요성을 이해했다. 기본 복사 생성자는 포인터 주소만 복사(얕은 복사)하기 때문에, 두 객체가 같은 메모리를 공유하게 되어 소멸 시 이중 해제(Double Free) 오류를 유발할 수 있다. 이를 방지하기 위해 **복사 생성자를 명시적으로 정의**하여, 새로운 메모리 공간을 할당하고 데이터를 일일이 복사하는 깊은 복사를 구현했다.

  - 동적 배열의 핵심 특징인 **자동 크기 조절(Resizing)** 로직을 구현했다. 데이터 추가(`Push_back`) 시 현재 용량(`Capacity`)이 부족하면 더 큰 메모리 블록을 새로 할당하고, 기존 데이터를 복사한 뒤 이전 메모리를 해제하는 과정을 통해 배열이 '동적으로' 늘어나는 것처럼 보이게 하는 원리를 파악했다.

<br/>

### 구현 과정

1.  **기본 구조 설계**: `template <typename T>`를 사용하여 클래스를 선언하고, 데이터 저장을 위한 포인터 `T* data`, 현재 요소 개수를 나타내는 `currentSize`, 할당된 총공간을 나타내는 `currentCapacity`를 멤버 변수로 정의했다.

2.  **생성자 및 소멸자 구현**:

      * **생성자**: 기본 생성자와 용량을 인자로 받는 생성자를 만들어 `new T[capacity]`를 통해 메모리를 최초 할당했다.
      * **소멸자**: `delete[] data`를 호출하여 클래스 인스턴스가 파괴될 때 할당했던 메모리를 반드시 해제하도록 구현했다. 이를 통해 메모리 누수를 방지한다.

3.  **핵심 기능 구현 (`Push_back`, `Pop_back`)**:

      * **`Push_back`**: 용량이 꽉 찼는지 (`currentCapacity <= currentSize`) 확인하고, 꽉 찼다면 정해진 크기(5)만큼 더 큰 새 배열을 할당하여 기존 데이터를 복사한 후 `data` 포인터를 교체했다. 이후 맨 뒤에 새 데이터를 추가하고 `currentSize`를 1 증가시켰다.
      * **`Pop_back`**: `currentSize`가 0이 아닐 경우, 단순히 `currentSize`를 1 감소시켜 마지막 요소를 논리적으로만 제거했다.

4.  **복사 생성자 구현 (깊은 복사)**: `SimpleVector<int> intVec3 = intVec2;`와 같은 구문을 위해 복사 생성자를 구현했다. 새로운 객체에 원본 객체의 `currentCapacity`만큼 새 메모리를 할당하고, `currentSize`만큼 실제 데이터를 `for` 루프를 통해 복사하여 완전히 독립된 객체를 만들었다.

5.  **정렬 기능 구현 (`SortData`)**: 제네릭 타입 `T`의 비교 연산(`>`)을 활용하여 **선택 정렬** 알고리즘을 구현했다. 배열을 순회하며 가장 작은 값을 찾아 현재 위치의 값과 교환하는 과정을 반복하여 데이터를 오름차순으로 정렬했다.

<br/>

## 느낀점

  - `std::vector`나 언리얼의 `TArray`처럼 당연하게 사용했던 컨테이너 내부에 이렇게 복잡한 메모리 관리와 정책이 숨어있다는 것을 알게 되었다. 특히 **깊은 복사의 필요성**을 직접 코드로 구현하며 체감할 수 있었다. 만약 복사 생성자를 구현하지 않았다면, `main` 함수에서 `intVec3`와 `intVec2`가 소멸될 때 같은 메모리를 두 번 해제하려다 프로그램이 죽는 끔찍한 상황이 발생했을 것이다.

  - `Push_back` 시 용량을 늘리는 전략(현재 코드에서는 `+5`)이 성능에 어떤 영향을 미칠지 고민하게 되었다. `std::vector`는 보통 현재 용량의 1.5배나 2배로 늘리는데, 이는 재할당 횟수를 줄여 **분할 상환 분석(Amortized Analysis)** 관점에서 `Push_back`의 시간 복잡도를 O(1)에 가깝게 만들기 위함이라는 것을 상기했다.


<br/>

-----

### 요약

| 학습 주제 | 핵심 내용 |
| :--- | :--- |
| **동적 배열 구현** | `new[]`, `delete[]`를 사용해 힙 메모리에 데이터를 저장하고 해제하는 커스텀 벡터 클래스를 구현했습니다. |
| **템플릿과 범용성** | 클래스 템플릿 `<typename T>`를 활용하여 어떤 데이터 타입이든 저장할 수 있는 범용 컨테이너를 만들었습니다. |
| **깊은 복사의 중요성** | 복사 생성자를 직접 구현하여, 포인터 멤버를 가진 클래스에서 발생할 수 있는 이중 해제 오류를 방지하는 방법을 익혔습니다. |
| **RAII 패턴** | 생성자에서 자원을 할당하고 소멸자에서 해제함으로써 자원 누수를 막는 RAII 패턴의 개념을 체득했습니다. |
| **자동 리사이징** | `Push_back` 시 용량이 부족할 때 자동으로 메모리를 재할당하는 로직을 구현하여 동적 배열의 핵심 원리를 이해했습니다. |


<br/>
