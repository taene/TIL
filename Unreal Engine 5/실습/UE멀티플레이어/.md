# 숫자 야구 게임 아키텍처

- 이 문서는 제공된 숫자 야구 게임 예제 코드를 바탕으로 언리얼 엔진의 멀티플레이어 기본 구조를 설명합니다. 모든 코드의 중심에는 '**서버 권위 모델**'이라는 핵심 원칙이 자리 잡고 있습니다.

## 서버가 모든 것을 결정합니다: 서버 권위 모델

멀티플레이어 게임에서 가장 중요한 원칙은 **모든 중요한 판단과 데이터 변경은 서버에서만 이루어져야 한다**는 것입니다. 클라이언트는 서버에 "이렇게 하고 싶습니다"라고 요청하고, 서버가 처리한 결과를 받아서 화면에 보여주는 역할만 합니다. 이렇게 하면 모든 플레이어가 동일한 게임 상태를 공유하게 되며, 치트와 같은 악의적인 조작을 방지할 수 있습니다.

숫자 야구 게임에서는 다음과 같은 요소들이 모두 서버의 권한에 해당합니다.
* 정답이 될 비밀 숫자
* 플레이어의 입력이 정답과 맞는지 판정하는 로직
* 플레이어의 시도 횟수 관리
* 승리, 무승부, 게임 리셋과 같은 게임 상태 변경

<br/>

## 게임의 핵심 요소들: 클래스 역할 분담

언리얼 엔진은 서버 권위 모델을 쉽게 구현할 수 있도록 몇 가지 기본 클래스를 제공합니다. 숫자 야구 게임은 이 클래스들의 역할을 명확하게 보여주는 좋은 예시입니다.

| 클래스 | 비유 | 역할 |
| :--- | :--- | :--- |
| **`ACXGameModeBase`** | **심판** | 게임의 모든 규칙과 흐름을 관리합니다. 비밀 번호를 생성하고, 플레이어의 추측을 판정하며, 승패를 결정합니다. 이 클래스는 **오직 서버에만 존재합니다**. |
| **`ACXPlayerController`** | **선수** | 플레이어의 입력을 받아 서버로 전달하는 창구입니다. 클라이언트가 채팅창에 숫자를 입력하면, `PlayerController`가 이 입력을 서버로 보냅니다. |
| **`ACXPlayerState`** | **개인 점수판** | 플레이어의 이름, 현재 시도 횟수 등 게임에 참여하는 **모든 사람이 알아야 할** 개인 정보를 저장합니다. 이 정보는 서버에서 관리되며 모든 클라이언트에게 자동으로 동기화(복제)됩니다. |

<br/>

## 서버와 클라이언트의 소통 방식

서버와 클라이언트는 목적에 따라 두 가지 주요 방식으로 소통합니다.

### 1. RPC (Remote Procedure Call)
클라이언트가 서버에 무언가를 **요청**할 때 사용합니다. 숫자 야구 게임에서 플레이어가 숫자를 입력하고 엔터를 치는 행위가 대표적입니다.
1.  클라이언트의 `PlayerController`에서 `ServerRPCPrintChatMessageString` 함수를 호출합니다.
2.  이 호출은 네트워크를 통해 서버로 전달됩니다.
3.  서버는 `ServerRPCPrintChatMessageString_Implementation` 함수를 실행하여 `GameMode`의 판정 로직을 구동합니다.

<br/>

### 2. 프로퍼티 리플리케이션 (Property Replication)
서버의 데이터가 변경되었을 때, 이 변경사항을 모든 클라이언트에게 자동으로 **전파**하는 기능입니다.
* **`PlayerState`의 시도 횟수 (`CurrentGuessCount`)**: 서버의 `GameMode`가 플레이어의 시도 횟수를 1 증가시키면, 이 값은 자동으로 모든 클라이언트에게 복제됩니다. 클라이언트는 이 복제된 값을 읽어 UI에 `(1/3)`과 같이 표시합니다.
* **`PlayerController`의 공지 메시지 (`NotificationText`)**: 서버의 `GameMode`가 "Player1이 승리했습니다."와 같은 공지 메시지를 결정하면, 각 플레이어의 `PlayerController`에 있는 `NotificationText` 변수에 이 값을 넣어줍니다. 이 변수 또한 리플리케이션되도록 설정되어 있어, 모든 클라이언트의 화면에 해당 공지가 뜨게 됩니다.

프로퍼티를 리플리케이션 하려면 세 가지 설정이 필요합니다:
1.  액터의 생성자에서 `bReplicates = true;`로 설정
2.  복제할 변수에 `UPROPERTY(Replicated)` 키워드 추가
3.  `GetLifetimeReplicatedProps` 함수에 `DOREPLIFETIME` 매크로로 변수 등록

<br/>

## 한 턴의 여정: 코드 흐름 따라가기

1.  **입력 (Client)**: 플레이어가 채팅창에 "123"을 입력합니다.
2.  **RPC 호출 (Client → Server)**: 클라이언트의 `ACXPlayerController`가 `ServerRPCPrintChatMessageString("Player1: 123")`을 호출합니다.
3.  **서버 도착 및 `GameMode` 호출 (Server)**: 서버가 RPC를 수신하고, `ACXGameModeBase`의 `PrintChatMessageString()` 함수를 실행합니다.
4.  **판정 및 상태 변경 (Server)**: `GameMode`는 "123"을 판정하고, 결과가 "1S0B"라고 판단합니다. 동시에 `ACXPlayerState`의 `CurrentGuessCount`를 1 증가시킵니다.
5.  **리플리케이션 (Server → All Clients)**: `CurrentGuessCount`의 값이 0에서 1로 변경되었으므로, 이 변경사항이 모든 클라이언트의 `ACXPlayerState`로 자동 전파됩니다.
6.  **결과 전송 및 UI 업데이트 (All Clients)**: `GameMode`가 판정 결과("1S0B")를 모든 클라이언트의 `PlayerController`에게 보내 UI를 갱신하도록 합니다. 동시에, 리플리케이션된 `CurrentGuessCount` 값 덕분에 채팅창의 시도 횟수 표시도 `(0/3)`에서 `(1/3)`으로 업데이트됩니다.

<br/>

- 이처럼 한 번의 입력이 서버와 클라이언트 사이를 오가며 게임을 진행시키는 구조입니다. 이 기본 흐름을 이해하는 것이 멀티플레이어 로직을 디버깅하고 확장하는 데 큰 도움이 될 겁니다.
