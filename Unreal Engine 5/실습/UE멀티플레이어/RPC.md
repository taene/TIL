## 학습 키워드

  * RPC (Remote Procedure Call)
  * `Server RPC`, `Client RPC`, `NetMulticast RPC`
  * 언리얼 엔진 네트워크 아키텍처
  * 데디케이티드 서버 (Dedicated Server)
  * `PlayerController`, `GameState`, `GameMode`
  * 액터 소유권 (Ownership) 및 책임 (Responsibility)
  * 리플리케이션 (Replication)
  * 확장성 (Scalability)
  * 라이라 (Lyra) 프로젝트 아키텍처

<br/>

## 학습 내용

### 배운 개념 요약

- **RPC (Remote Procedure Call)** 는 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간에 있는 프로시저(함수)를 마치 로컬 프로시저처럼 호출할 수 있게 하는 기술이다. 언리얼 엔진의 데디케이티드 서버 환경에서는 클라이언트 간 직접 통신이 불가능하므로, 모든 통신은 서버를 경유하는 RPC를 통해 이루어진다.

**언리얼 엔진의 3가지 RPC 유형**

| RPC 유형 | UFUNCTION 지정자 | 호출 주체 → 실행 주체 | 설명 및 비유 |
| :--- | :--- | :--- | :--- |
| **Server RPC** | `Server` | 클라이언트 → 서버 | 클라이언트가 서버에게 특정 함수를 실행해달라고 **'보고'** 하는 역할이다. 클라이언트의 입력 처리 결과를 서버에 알릴 때 주로 사용한다. |
| **Client RPC** | `Client` | 서버 → 특정 클라이언트 | 서버가 특정 클라이언트에게 함수 실행을 **'명령'** 하는 역할이다. 이 RPC를 호출하는 액터는 반드시 해당 클라이언트가 소유해야 한다. |
| **NetMulticast RPC** | `NetMulticast` | 서버 → 모든 클라이언트 | 서버가 자신을 포함한 모든 클라이언트에게 함수 실행을 **'공지'** 하는 역할이다. 모든 클라이언트가 알아야 할 전역 이벤트에 사용한다. |

#### 주요 게임 프레임워크 액터의 복제(Replication) 규칙
- RPC를 어느 액터에 구현할지 결정하기 위해서는 각 액터의 존재 범위와 복제 규칙을 반드시 이해해야 한다.

  * **`AGameModeBase`**: **서버에만 존재한다.** 게임의 규칙, 승패 판정 등 핵심 로직을 담당한다. 클라이언트에는 존재하지 않으므로 클라이언트가 실행해야 할 RPC를 여기에 만들 수 없다.
  * **`AGameStateBase`**: **서버에서 생성되어 모든 클라이언트에게 복제된다.** 게임 시간, 점수 등 모든 플레이어가 공유해야 할 '게임의 공통 상태'를 담는다. 따라서 `NetMulticast RPC`의 완벽한 후보이다.
  * **`APlayerController`**: **서버와 소유자인 클라이언트에만 존재한다.** 각 클라이언트는 오직 자기 자신의 `PlayerController`만 가지고 있다. 서버는 모든 플레이어의 `PlayerController`를 알고 있다. 플레이어의 입력을 받아 처리하는 대리인 역할을 한다.

<br/>

### 구현 과정

두 가지 멀티플레이 기능을 구현하며, 기능의 성격에 따라 어떤 RPC와 액터를 선택해야 하는지, 그리고 그것이 왜 더 나은 설계인지 깊이 있게 학습했다.

#### 1. 멀티플레이 채팅 구현 (플레이어 주도 액션)

  * **목표**: 한 클라이언트가 입력한 메시지를 모든 클라이언트의 화면에 표시한다.
  * **핵심 흐름**: `Client A` → `Server` → `All Clients (A, B, C...)`
  * **구현 단계**:
    1.  **클라이언트 → 서버**: 플레이어가 채팅을 입력하면, 해당 플레이어의 `ACXPlayerController`에서 `UFUNCTION(Server)`로 지정된 `ServerRPCPrintChatMessageString` 함수를 호출한다. 플레이어의 행동에서 비롯된 요청이므로 `PlayerController`가 책임을 지는 것이 논리적으로 타당하다.
    2.  **서버 → 모든 클라이언트**: 서버에서 실행된 `ServerRPCPrintChatMessageString_Implementation` 함수는, 월드에 존재하는 모든 `ACXPlayerController` 액터를 순회(`TActorIterator`)한다. 그리고 각 `PlayerController`에 대해 `UFUNCTION(Client)`으로 지정된 `ClientRPCPrintChatMessageString` 함수를 호출한다.
  * **설계 분석**: `PlayerController`에서 `NetMulticast RPC`를 사용하지 않은 이유는 `PlayerController`의 복제 규칙 때문이다. 만약 `PlayerController`에서 멀티캐스트를 호출하면, 해당 `PlayerController`가 존재하는 서버와 소유 클라이언트에게만 메시지가 전달될 뿐, 다른 클라이언트들은 받지 못한다. 따라서 서버가 모든 `PlayerController`를 직접 찾아 각각에게 `Client RPC`로 명령을 내리는 방식이 올바른 접근이다.

<br/>

#### 2. 서버 접속 알림 구현 (시스템 레벨 이벤트)

  * **목표**: 새로운 플레이어가 게임에 접속하면, 모든 클라이언트에게 알림 메시지를 표시한다.
  * **핵심 흐름**: `Server Event` → `All Clients`
  * **구현 단계**:
    1.  **이벤트 감지**: 플레이어가 성공적으로 로그인하면 서버의 `ACXGameModeBase::OnPostLogin` 함수가 자동으로 호출된다. 게임의 규칙을 관장하는 `GameMode`가 이벤트를 감지하는 것은 자연스러운 역할이다.
    2.  **전파**: `OnPostLogin` 함수 내에서, 서버는 `GetGameState<ACXGameStateBase>()`를 통해 `GameState`에 접근한다. 그리고 `GameState`에 `UFUNCTION(NetMulticast)`로 선언된 `MulticastRPCBroadcastLoginMessage` 함수를 호출한다.
  * **설계 분석**: 이 RPC는 서버에만 존재하는 `GameMode`가 아닌, 모든 클라이언트에게 복제되는 `GameState`에 구현해야 한다. `GameState`는 '모두가 공유하는 상태'를 담는 액터이므로, '모두에게 알리는 공지' 기능을 수행하기에 가장 적합한 장소이다.

<br/>

#### 심층 분석: 왜 채팅은 `PlayerController` 순회, 접속 알림은 `GameState` 멀티캐스트인가?

기술적으로 채팅 기능도 `GameState`의 멀티캐스트로 구현할 수 있지만, 이는 좋은 설계가 아니다. 그 이유는 다음과 같다.

  * **소유권과 책임**: 채팅 메시지는 특정 플레이어의 행동에서 비롯된 데이터이다. 따라서 플레이어의 대리인인 `PlayerController`가 그 처리 흐름을 책임지는 것이 명확하다. 반면 접속 알림은 특정 플레이어의 행동이 아닌, 시스템 레벨의 이벤트이므로 `GameState`가 공통 상태로서 알리는 것이 적합하다.
  * **컨텍스트와 유연성**: `PlayerController`를 순회하는 방식은 서버가 메시지를 받을 대상(`TargetPC`)과 보낸 주체(`SenderPC`)를 명확히 인지하고 있음을 의미한다. 이를 통해 "A가 B를 차단했다면 B에게는 메시지를 보내지 않는다"와 같은 복잡한 컨텍스트 기반 필터링 로직을 서버 측에서 손쉽게 구현할 수 있다.
  * **확장성**: 향후 **'팀 채팅', '귓속말'** 기능을 추가한다고 가정하면, `PlayerController` 순회 방식은 `if` 조건문 몇 줄로 특정 대상에게만 `Client RPC`를 보내도록 쉽게 확장할 수 있다. 하지만 `GameState` 멀티캐스트 방식은 불필요한 정보까지 모든 클라이언트에게 전송한 후 각 클라이언트가 알아서 필터링해야 하므로 비효율적이고 보안에 취약한 구조가 된다.

<br/>

## 느낀점

- 단순히 코드를 따라 기능을 구현하는 수준을 넘어, '왜 이 코드는 이렇게 작성되었는가?'에 대한 근본적인 이유를 파고들면서 네트워크 아키텍처 설계의 깊이를 체감했다. 처음에는 `PlayerController`를 일일이 순회하는 방식이 비효율적이라고 생각했지만, 이것이 **소유권, 컨텍스트, 확장성**이라는 소프트웨어 공학의 중요 원칙을 지키기 위한 최선의 설계임을 깨달았다.

- 이번 학습을 통해 기능의 성격(플레이어 주도 행동인가, 시스템 레벨 이벤트인가)에 따라 사용해야 할 RPC의 종류와 책임을 져야 할 액터가 달라진다는 명확한 기준을 세울 수 있었다. 라이라(Lyra)와 같은 AAA급 프로젝트가 왜 `GameplayMessageSubsystem`이나 별도의 서브시스템을 두어 이러한 로직을 더욱 추상화하고 분리하는지에 대한 이유도 어렴풋이 짐작하게 되었다.

- 앞으로 네트워크 기능을 구현할 때, 단순히 '동작하는 코드'를 넘어 **'올바른 책임을 부여받은, 확장 가능한 코드'**를 작성하기 위해 항상 "이 데이터와 로직의 진정한 주인은 누구인가?"를 먼저 질문하는 개발자가 되어야겠다고 다짐한다.
