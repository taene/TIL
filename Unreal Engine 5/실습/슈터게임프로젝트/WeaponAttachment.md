## 학습 키워드
- 데이터 중심 설계 (Data-Driven Design)
- 언리얼 엔진 데이터 테이블 (Data Table), CSV 임포트
- `TSoftObjectPtr`와 비동기 애셋 로딩 (Asynchronous Loading)
- `TMap`을 이용한 데이터 관리 및 컴포넌트 매핑
- `USkeletalMeshComponent` (컴포넌트)와 `USkeletalMesh` (애셋)의 차이
- 커스텀 스탯 시스템 연동 (`FStatContainer`, `UStatContainerCollection`)
- 액터 생명주기 (Actor Lifecycle)와 `assert`를 이용한 디버깅


## 학습 내용
### 배운 개념 요약
- **데이터 중심 설계의 중요성**: 게임의 핵심 데이터(캐릭터 스탯, 총기 부품 구성, 파츠별 스탯 등)를 C++ 코드에서 분리하여 데이터 테이블(CSV 파일)로 관리하는 방식의 중요성을 배웠다. 이를 통해 프로그래머의 개입 없이 기획자가 게임 밸런스를 직접 수정하고 콘텐츠를 확장할 수 있는 유연하고 전문적인 아키텍처를 구축할 수 있었다.
- **애셋과 컴포넌트의 명확한 분리**: `USkeletalMesh`는 순수한 데이터 애셋이며, 위치 정보를 갖는 것은 그것을 담는 그릇인 `USkeletalMeshComponent`라는 것을 명확히 이해했다. 이 개념은 `SetSkeletalMesh` 호출 시 위치가 바뀌어 보이던 '피벗 불일치' 문제를 진단하고 해결하는 데 결정적인 역할을 했다.
- **체계적인 스탯 관리**: 각 부착물이 독립적인 스탯 컨테이너(`FStatContainer`)를 갖고, 이를 총을 소유한 캐릭터의 중앙 스탯 컬렉션(`UStatContainerCollection`)에 동적으로 추가/제거하는 방식을 배웠다. 이를 통해 여러 장비의 스탯이 실시간으로 합산되는 시스템의 원리를 파악했다.
- **비동기 로딩의 필요성**: `TSoftObjectPtr`와 `StreamableManager`를 사용해, 데이터 테이블에 정의된 수많은 메시 애셋들을 게임 시작 시 모두 로딩하는 것이 아니라, 필요할 때만 비동기적으로 로딩하여 게임의 끊김 현상(Hitch)을 방지하고 초기 로딩 시간을 단축하는 방법을 학습했다.

### 구현 과정
1.  **초기 구상**: `GunActor`에 여러 개의 `USkeletalMeshComponent`를 만들어 두고, 데이터 테이블에 정의된 메시를 교체하는 아이디어로 시작했다.
2.  **데이터 구조 설계**: 총 3개의 데이터 테이블을 사용하는 구조로 발전시켰다.
    -   `CharacterStats.csv`: 캐릭터의 기본 스탯 정의
    -   `WeaponStatData.csv`: 총의 종류별 기본 부착물 조합 정의
    -   `WeaponAttachmentData.csv`: 개별 부착물 파츠의 메시 경로, 스탯 등 상세 정보 정의
3.  **C++ 클래스 재설계**:
    -   `AGunActor`와 `ACharacter` 클래스의 `BeginPlay` 로직을 수정하여, 각자에게 할당된 데이터 테이블 ID를 기반으로 자신의 초기 상태(기본 스탯, 기본 파츠)를 스스로 구성하도록 변경했다.
    -   `TMap<EAttachmentSlot, USkeletalMeshComponent*>`을 활용하여 코드 내에서 `switch`문 없이 깔끔하게 슬롯과 컴포넌트를 연결했다.
4.  **핵심 기능 구현 (`SetAttachmentByIndex`)**:
    -   기존에 장착된 파츠의 스탯 컨테이너를 캐릭터의 중앙 컬렉션에서 제거하고 메시를 비우는 `UnEquipAttachment` 로직을 구현했다.
    -   데이터 테이블에서 새로운 파츠의 정보를 찾아, 스탯을 담은 `FStatContainer`를 새로 생성하고 중앙 컬렉션에 추가했다.
    -   동시에 `TSoftObjectPtr`에 저장된 경로를 이용해 새 메시를 비동기 로드하여 컴포넌트에 적용했다.
5.  **문제 해결**:
    -   **크래시 해결**: `assert`문의 조건이 논리적으로 반대로 되어 있던 문제를 파악하고, `if`문을 사용한 안전한 조기 리턴 방식으로 코드를 수정했다.
    -   **위치 문제 해결**: 메시 교체 시 위치가 틀어지는 현상이 `SetSkeletalMesh` 함수가 아닌, 각 메시 애셋의 '원점(Pivot)'이 불일치하기 때문임을 파악하고, 근본적인 해결책(DCC 툴에서 수정)과 임시방편(코드에서 오프셋 보정)을 학습했다.

## 느낀점
- 단순히 기능을 구현하는 것을 넘어, **누가, 어떻게 이 데이터를 관리하고 확장할 것인가**를 고민하는 것이 좋은 아키텍처의 시작임을 깨달았다. 데이터 중심 설계는 프로그래머의 편의뿐만 아니라 팀 전체의 작업 효율을 극대화하는 핵심적인 철학이었다.
- `TMap`을 적재적소에 활용하는 것이 얼마나 코드를 간결하고 유연하게 만드는지 체감할 수 있었다. 특히 `UPROPERTY`로 노출했을 때 에디터에서 디자이너에게 제공하는 편의성은 기대 이상이었다.
- 눈에 보이는 현상(위치가 바뀐다)과 실제 원인(피벗이 다르다)이 다를 수 있다는 것을 경험했다. 엔진의 동작 원리를 정확히 이해하는 것이 버그를 빠르고 정확하게 잡는 데 얼마나 중요한지 다시 한번 느꼈다.
- 처음에는 복잡해 보였지만, 최종적으로 완성된 3개의 데이터 테이블이 서로 유기적으로 맞물려 캐릭터와 총의 상태를 결정하는 구조를 보니, 확장성과 유지보수성이 높은 견고한 시스템을 내 손으로 만들었다는 성취감이 크다.
