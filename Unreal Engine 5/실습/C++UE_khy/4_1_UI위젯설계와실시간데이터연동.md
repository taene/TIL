## 학습 키워드
  - UMG (Unreal Motion Graphics)
  - 위젯 블루프린트 (Widget Blueprint)
  - HUD (Heads-Up Display)
  - PlayerController
  - GameState
  - 데이터 연동 (Data Binding vs. SetText)

<br/>


## 학습 내용

### 배운 개념 요약

  - **UMG (Unreal Motion Graphics)와 위젯 블루프린트**

      - **UMG**는 언리얼 엔진의 강력한 UI 제작 시스템으로, **위젯 블루프린트**(Widget Blueprint)를 통해 시각적으로 UI를 설계한다. 이는 과거의 Canvas 기반 HUD보다 훨씬 직관적이고 강력한 기능을 제공한다.
      - 위젯 블루프린트는 UI의 시각적 배치를 담당하는 **디자이너(Designer) 탭**과, 버튼 클릭 이벤트 등 UI 관련 로직을 작성하는 **그래프(Graph) 탭**으로 구성된다.

  - **HUD 생성과 표시**

      - UI 위젯은 플레이어의 입력과 상호작용하는 화면 요소이므로, 일반적으로 `PlayerController`에서 생성하고 관리하는 것이 적합하다.
      - C++ 코드에서 `CreateWidget` 함수로 위젯의 인스턴스를 생성하고, `AddToViewport` 함수를 호출하여 화면에 표시한다.
      - `CreateWidget` 같은 UMG 관련 C++ 함수를 사용하려면, 프로젝트의 `.Build.cs` 파일에 `"UMG"` 모듈을 반드시 추가해야 한다.

  - **UI 데이터 연동 방식**

      - 게임 내 데이터(점수, 시간 등)를 UI에 실시간으로 표시하는 방법은 크게 두 가지가 있다.

    <!-- end list -->

    1.  **바인딩 (Binding)**: 위젯의 텍스트 같은 속성을 특정 함수에 직접 연결하는 방식이다. 이 함수는 매 프레임 호출되어 최신 값을 반환하므로 구현이 매우 간단하지만, UI 요소가 많아지면 성능 저하의 원인이 될 수 있다.
    2.  **수동 업데이트 (`SetText`)**: 데이터가 변경되는 시점에 직접 위젯의 참조를 얻어와 `SetText`와 같은 함수를 명시적으로 호출하는 방식이다. 바인딩보다 코드가 더 필요하지만, 불필요한 업데이트를 줄일 수 있어 성능상 이점이 있다. 이번 강의에서는 이 방식을 사용했다.

<br/>

### 구현 과정

#### 1. UI 위젯 디자인 (WBP_HUD)

1.  콘텐츠 브라우저에서 `User Interface > Widget Blueprint`를 선택하여 `UserWidget`을 부모로 하는 `WBP_HUD` 에셋을 생성한다.
2.  `Designer` 탭에서 `Canvas Panel`을 추가하여 UI 요소들을 자유롭게 배치할 '도화지'를 마련한다.
3.  `Text Block` 위젯을 3개 추가하여 각각 점수, 현재 레벨, 남은 시간을 표시하도록 배치하고, `Details` 패널에서 폰트, 크기, 색상 등을 디자인한다.

#### 2. C++에서 HUD 생성 및 화면에 표시

1.  `ASpartaPlayerController.h`에 위젯 블루프린트 클래스를 에디터에서 받아올 `TSubclassOf<UUserWidget> HUDWidgetClass` 변수와, 생성된 위젯 인스턴스를 저장할 `UUserWidget* HUDWidgetInstance` 변수를 선언한다.

2.  `ASpartaPlayerController.cpp`의 `BeginPlay()` 함수에서 `HUDWidgetClass`가 유효한지 확인한 후, `CreateWidget`으로 인스턴스를 생성하고 `AddToViewport`로 화면에 추가한다.

    ```cpp
    // SpartaPlayerController.cpp의 BeginPlay()
    void ASpartaPlayerController::BeginPlay()
    {
        Super::BeginPlay();

        // ... Input Mapping Context 설정 ...

        // HUD 위젯 클래스가 지정되어 있으면
        if (HUDWidgetClass)
        {
            // 위젯을 생성하고 인스턴스를 저장
            HUDWidgetInstance = CreateWidget<UUserWidget>(this, HUDWidgetClass);
            if (HUDWidgetInstance)
            {
                // 뷰포트에 추가하여 화면에 표시
                HUDWidgetInstance->AddToViewport();
            }
        }
    }
    ```

3.  `BP_SpartaPlayerController` 블루프린트를 열고, `HUDWidgetClass` 프로퍼티에 위에서 만든 `WBP_HUD` 에셋을 할당한다.

#### 3. GameState와 데이터 연동 (SetText 방식)

1.  **`GameState`에 UI 업데이트 로직 추가**: `ASpartaGameState.cpp`에 `UpdateHUD` 함수를 만들고, `BeginPlay`에서 0.1초마다 이 함수를 반복적으로 호출하는 타이머를 설정한다. 이 타이머는 남은 시간처럼 지속적으로 변하는 값을 UI에 반영하기 위함이다.

2.  **`UpdateHUD` 함수 구현**:

      - `GetWorld()->GetFirstPlayerController()`로 플레이어 컨트롤러를 가져온다.
      - 컨트롤러에서 `HUDWidgetInstance`를 가져온다.
      - `WidgetTree->FindWidget<UTextBlock>(TEXT("이름"))` (PDF 코드에서는 생략되었으나 일반적인 방식)을 사용해 위젯 내의 특정 `TextBlock`를 이름으로 찾는다.
      - `GameState`의 `LevelTimerHandle`에서 남은 시간을, `GameInstance`에서 누적 점수를, `GameState`에서 현재 레벨 인덱스를 가져온다.
      - `FString::Printf`로 텍스트 형식을 만들고, `FText::FromString`으로 변환한 뒤, 각 `TextBlock`의 `SetText` 함수를 호출해 UI를 갱신한다.

3.  **데이터 변경 시점에도 업데이트 호출**: `StartLevel`, `OnGameOver` 등 게임 상태가 크게 변하는 시점에도 `UpdateHUD()`를 직접 호출하여 UI가 즉시 갱신되도록 한다.

    ```cpp
    // SpartaGameState.cpp
    void ASpartaGameState::UpdateHUD()
    {
        // 첫 번째 플레이어 컨트롤러 가져오기
        if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())
        {
            // 커스텀 컨트롤러로 캐스팅
            ASpartaPlayerController* SpartaPlayerController = Cast<ASpartaPlayerController>(PlayerController);
            if (SpartaPlayerController)
            {
                // 컨트롤러에서 HUD 위젯 인스턴스 가져오기
                if (UUserWidget* HUDWidget = SpartaPlayerController->GetHUDWidget())
                {
                    // 위젯에서 'TimeText'라는 이름의 텍스트 블록 찾기 (예시)
                    if (UTextBlock* TimeText = Cast<UTextBlock>(HUDWidget->GetWidgetFromName(TEXT("TimeText"))))
                    {
                        // 타이머의 남은 시간을 가져와 텍스트로 설정
                        float RemainingTime = GetWorldTimerManager().GetTimerRemaining(LevelTimerHandle);
                        TimeText->SetText(FText::FromString(FString::Printf(TEXT("Time: %.1f"), RemainingTime)));
                    }
                    
                    // ... ScoreText, LevelIndexText 등도 유사하게 처리 ...
                }
            }
        }
    }
    ```

<br/>


## 느낀점

  - UI 로직을 `PlayerController`와 `GameState`에 분산하여 관리하는 방식이 체계적으로 느껴졌다. 위젯의 생성과 소멸 같은 생명주기는 `PlayerController`가 책임지고, 위젯에 표시될 데이터의 갱신은 데이터의 원천인 `GameState`가 책임지는 구조는 역할 분담이 명확해서 이해하기 쉬웠다.
  - UI 업데이트 방식에서 '바인딩'과 '수동 업데이트'의 장단점을 비교해볼 수 있는 좋은 기회였다. 바인딩은 매우 편리하지만 모든 것을 바인딩에 의존하면 성능 문제를 야기할 수 있다. 반면, 타이머를 이용한 주기적인 수동 업데이트와 이벤트 발생 시점의 즉각적인 업데이트를 조합하는 방식은 성능과 실시간성을 모두 잡을 수 있는 실용적인 접근법이라고 생각한다.
  - C++ 코드로 UI의 기본 구조와 데이터 흐름을 만들고, 실제 디자인과 배치는 위젯 블루프린트에서 시각적으로 처리하는 하이브리드 워크플로우의 강력함을 다시 한번 느꼈다. 프로그래머와 UI 디자이너의 협업 효율을 극대화할 수 있는 구조다.

-----

### 요약

- 게임의 HUD는 UMG(Unreal Motion Graphics)의 **위젯 블루프린트**로 디자인한다.
- C++ `PlayerController`의 `BeginPlay`에서 `CreateWidget` 함수로 위젯을 생성하고 `AddToViewport`로 화면에 표시한다.
- 실시간 데이터 연동은, 데이터의 원천인 `GameState`에서 주기적인 타이머를 통해 `UpdateHUD` 함수를 호출하고, 이 함수 안에서 UI 위젯 내의 각 `TextBlock`를 찾아 `SetText` 함수로 내용을 직접 갱신하는 방식으로 구현한다.
