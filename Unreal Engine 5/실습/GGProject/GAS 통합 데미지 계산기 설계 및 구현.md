## 학습 키워드 

  * Gameplay Ability System (GAS)
  * `UGameplayEffectExecutionCalculation`
  * 데미지 공식 아키텍처
  * 데이터 주도 설계 (Data-Driven Design)
  * 게임플레이 태그 (`GameplayTag`)
  * 느슨한 결합 (Loose Coupling)
  * 연쇄 효과 (Chain Reaction)
  * 데이터 테이블 (`DataTable`)

-----

## 학습 내용 

### 배운 개념 요약 

**하나의 통합된 `UGameplayEffectExecutionCalculation`(이하 Execution)을 사용하여 게임의 모든 피해를 처리하는 시스템을 설계하고 구현했다.** 이 과정에서 단순한 공식 구현을 넘어, 라이라(Lyra) 프로젝트가 지향하는 확장 가능하고 데이터 중심적인 아키텍처를 깊이 있게 탐구했다.

**1. 데미지 공식의 전체 흐름을 이해한다.**
최종 피해량은 여러 단계의 연산을 거쳐 결정된다. 각 단계는 게임 밸런스에 중요한 역할을 한다.

  * **공격 데미지**: `(기본 데미지 + 스킬 데미지) * 스킬 배율 * 치명타 피해 배율`
  * **유효 방어력**: `원래 방어력 * (1 - 방어력 관통)`
  * **피해 감소율**: `유효 방어력 / (유효 방어력 + 방어 계수)`
  * **최종 데미지**: `((공격 데미지 * (1 - 피해 감소율)) - 고정 피해 감소) * (1 + 데미지 증폭률)`

**2. `FGameplayEffectSpec`은 계산에 필요한 모든 정보를 담은 '데이터 묶음'이다.**
`Execution`이 `EffectSpec`을 인자로 받는다는 것은 계산에 필요한 모든 문맥 정보를 이미 가지고 있음을 의미한다.

  * **`Def->AssetTags`**: `GameplayEffect` 에셋에 영구적으로 저장된 고유 태그. 피해 타입을 구분하는 핵심 정보다.
    * `Spec.Def->GetGrantedTags().HasTag(TagName)`
  * `SetByCallerMagnitudes`: 어빌리티가 동적으로 주입한 수치. 스킬 자체의 피해량 등을 전달한다.
  * `Context`: 시전자, 피격 위치, 사용된 어빌리티 등 모든 배경 정보를 담고 있다.
  * `CapturedSourceTags`: 효과 생성 시점의 공격자가 가진 태그의 스냅샷.

**3. '느슨한 결합'의 핵심은 `GameplayTag`이다.**
물리/마법 피해를 구분하기 위해 `Execution`이 `if (클래스 == UGE_Fireball::StaticClass())` 와 같이 콘텐츠의 종류를 직접 알게 되면 '강한 결합'이 발생하여 유지보수가 불가능해진다. 대신, `Execution`은 `if (태그 == Damage.Type.Magic)` 와 같이 **미리 약속된 규칙**(태그)에만 의존해야 한다. 이를 통해 `Execution` 코드 변경 없이 디자이너가 새로운 마법 스킬을 무한정 추가할 수 있는 **'느슨한 결합'** 상태가 된다.

**4. 복합/의존적 피해는 '연쇄 반응'으로 해결한다.**
'화염 인챈트된 검'과 같이 하나의 행위가 여러 종류의 피해를 유발하거나, 한 피해가 다른 피해에 영향을 주는 경우, **`Execution`이 스스로 또 다른 `GameplayEffectSpec`을 생성하여 적용**하는 '연쇄 반응' 아키텍처를 사용한다. 예를 들어, 물리 피해 `Execution`은 물리 피해를 적용한 뒤, 공격자가 가진 '인챈트 버프'를 확인하고, 물리 피해량에 기반한 보너스 마법 피해 `EffectSpec`을 새로 생성하여 타겟에게 적용시킨다.

**5. `if-else` 지옥은 `DataTable`로 해결한다.**
'화염', '냉기', '번개' 인챈트마다 `if-else` 분기를 추가하는 것은 확장성 없는 설계이다. 이 문제를 해결하기 위해, 인챈트의 모든 정보를 담는 **`FEnchantmentDefinition` 구조체**와 `DataTable`을 사용한다. `Execution` 코드는 더 이상 '화염'의 존재를 알 필요 없이, 그저 "공격자가 가진 태그와 일치하는 데이터 테이블 행을 찾아, 거기에 적힌 대로 실행하라"는 **완전히 범용적인 로직**만 갖게 된다. 이로써 모든 게임 콘텐츠 로직이 C++ 코드에서 데이터 에셋으로 분리된다.

-----

### 구현 과정 

1.  **통합 계산기 생성**: 모든 피해 계산을 담당할 `UGGDamageExecution` 클래스를 생성했다.
2.  **피해 타입 구분**: `GameplayEffect` 에셋의 **`AssetTags`**에 `Damage.Type.Physical` 또는 `Damage.Type.Magic` 태그를 부여하는 규칙을 세웠다. `Execution`에서는 `Spec.Def->AssetTags.HasTag()`를 통해 이 태그를 확인하고, 그에 맞는 능력치(물리 증폭 vs 마법 증폭)를 선택하여 계산을 진행하도록 구현했다.
3.  **복합 피해 처리**: '인챈트된 검' 공격의 경우, `GameplayAbility` 단에서 캐릭터의 상태(인챈트 버프 태그)를 확인하고, **기본 물리 피해 GE와 추가 마법 피해 GE를 각각 생성하여 적용**하는 방식으로 구현했다. `Execution`은 독립적인 두 개의 계산 요청을 순차적으로 처리할 뿐이다.
4.  **의존적 피해 처리 (연쇄 반응)**: '인챈트 피해가 물리 피해에 기반'하는 조건을 구현하기 위해, 물리 피해를 처리하는 `Execution`이 최종 물리 피해량을 계산한 뒤, 이 값을 기반으로 보너스 마법 피해량을 산출했다. 그리고 `SetByCallerMagnitude`에 이 값을 담은 **새로운 마법 피해 `EffectSpec`을 즉석에서 생성하여 타겟에게 적용**하는 '연쇄' 로직을 구현했다.
5.  **데이터 테이블 리팩토링**: `if-else` 문을 제거하기 위해 `FEnchantmentDefinition` 구조체와 `DT_EnchantmentDefinitions` 데이터 테이블을 생성했다. `Execution` 코드를 리팩토링하여, 공격자가 가진 태그와 데이터 테이블의 행 이름을 비교하고, 일치하는 행의 데이터를 읽어 연쇄 효과를 발동시키는 범용적인 시스템을 구축했다.
6.  **워크플로우 개선**: 디자이너의 실수를 줄이고 편의성을 높이기 위해, `UGameplayEffect`를 상속받는 `UGGGameplayEffect` 커스텀 클래스를 만들었다. `PostEditChangeProperty` 함수를 오버라이드하여, 에디터에서 `bIsMagicDamage`와 같은 `bool` 변수를 체크하는 것만으로 **자동으로 `AssetTags`에 올바른 태그가 추가/제거**되도록 자동화 로직을 구현했다.
7.  **최종 적용**: 모든 계산이 끝난 `FinalDamage` 값을 `OutExecutionOutput.AddOutputModifier()`를 통해 시스템에 전달했다. 라이라의 표준 방식에 따라 `Health`를 직접 수정하는 대신 `Damage` 속성에 피해를 더하는 방식으로 구현했다.

-----

## 느낀점 

단순한 데미지 계산기 하나를 만드는 과정이 게임 아키텍처 전반에 대한 깊은 고찰로 이어졌다. 처음에는 기능 구현에만 집중했지만, 친구와의 대화와 멘토링을 통해 '어떻게 하면 확장 가능하고, 유지보수하기 좋으며, 디자이너와 협업하기 좋은 시스템을 만들 수 있을까'를 끊임없이 고민하게 되었다.
