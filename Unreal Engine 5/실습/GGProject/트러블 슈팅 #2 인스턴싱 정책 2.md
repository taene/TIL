## 학습 키워드

- Gameplay Ability System
- Multiplayer
- ReplicationPolicy
- InstancingPolicy
- Local Predicted

<br/>

## 학습 내용

### 배운 개념 요약

`LocalPredicted`로 설정된 `Gameplay Ability`에서 오류가 발생하여 그 원인과 해결책을 학습했다. 핵심은 **어빌리티 객체 자체의 복제**와 **어빌리티 실행 결과의 복제**를 명확히 구분하는 것이다.

오류 메시지 `TryActivateAbility called on ability that is InstancedPerExecution and Replicated. This is an invalid configuration.`는 `InstancingPolicy`가 `InstancedPerExecution`으로 설정된 어빌리티는 `ReplicationPolicy`를 `ReplicateYes`로 설정할 수 없음을 의미한다.

  * **`InstancingPolicy::InstancedPerExecution`**: 어빌리티가 활성화될 때마다 일회성 인스턴스를 생성하고 종료 시 즉시 파괴한다. 이 인스턴스는 상태를 유지하지 않는 임시 객체이다.
  * **`ReplicationPolicy::ReplicateYes`**: 어빌리티 '객체' 자체를 서버에서 클라이언트로 복제하여 객체 내부의 변수 상태를 동기화할 때 사용한다. 이는 `InstancedPerActor`처럼 상태가 유지되는 어빌리티를 위한 정책이다.
  * **`LocalPredicted`의 동작 원리**: 예측 어빌리티는 서버와 클라이언트가 하나의 어빌리티 객체를 공유하는 것이 아니다. 대신, 클라이언트와 서버가 **각자 독립적인 로컬 인스턴스를 생성하여 동일한 로직을 실행**한다.

따라서 일회성으로 생성되었다 사라지는 `InstancedPerExecution` 객체를 네트워크로 복제하려는 시도는 논리적으로 모순이며, 엔진은 이를 금지한다. `LocalPredicted` 어빌리티에서 동기화가 필요한 것은 어빌리티 객체 자체가 아니라, 그 어빌리티가 만들어내는 **결과물**(예: 스폰되는 액터, 적용되는 게임플레이 이펙트)이다.

올바른 멀티플레이어 패턴은 다음과 같다.

1.  **Gameplay Ability**: `ReplicationPolicy`를 `ReplicateNo`로 설정한다. 어빌리티는 단지 "실행하라"는 보이지 않는 명령의 역할만 수행한다.
2.  **결과물(Actor 등)**: 어빌리티를 통해 생성되는 발사체, 이펙트 등의 액터는 `bReplicates = true`로 설정하여 월드 상의 모든 플레이어에게 보이도록 동기화한다.

### 구현 과정

**1. 문제 발생 코드**

`UGGSkillAbility`의 생성자에서 `LocalPredicted`를 사용하며 어빌리티 객체 자체를 리플리케이트하도록 설정했다.

```cpp
// GGSkillAbility.cpp - 수정 전
UGGSkillAbility::UGGSkillAbility()
{
	// 잘못된 설정
	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateYes;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerExecution;
}
```

이로 인해 어빌리티 활성화 시 `Invalid configuration` 오류가 발생했다.

**2. 문제 해결 코드**

어빌리티 객체 자체는 복제하지 않도록 `ReplicationPolicy`를 `ReplicateNo`로 변경하여 문제를 해결했다. 어빌리티의 결과물인 `AGGSkillActor`는 모든 클라이언트에게 보여야 하므로 `bReplicates = true` 설정을 유지한다.

```cpp
// GGSkillAbility.cpp - 수정 후
UGGSkillAbility::UGGSkillAbility()
{
	// 올바른 설정
	// LocalPredicted 어빌리티는 객체를 복제하는 것이 아니라, 각 머신에서 독립적으로 실행된다.
	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerExecution;
}

// GGSkillActor.cpp - 올바른 설정 유지
AGGSkillActor::AGGSkillActor()
{
    // ...
	// 어빌리티의 '결과물'인 스킬 액터는 모든 클라이언트에게 복제되어야 한다.
	bReplicates = true;
}
```

이 수정을 통해 `LocalPredicted` 어빌리티의 본래 의도대로, 클라이언트에서는 즉각적인 예측 실행이 가능해지고 서버와의 결과 동기화는 리플리케이트되는 액터를 통해 이루어지도록 구현했다.

<br/>

## 느낀점

단순히 오류를 해결하는 것을 넘어, GAS의 각 정책이 멀티플레이어 환경에서 어떤 철학을 가지고 설계되었는지 깊이 이해하는 계기가 되었다. 특히 `LocalPredicted` 어빌리티에서 '어빌리티 객체'와 '어빌리티의 결과물'을 분리해서 생각해야 한다는 점이 중요했다. 어빌리티는 보이지 않는 '명령'이고, 실제 동기화는 눈에 보이는 '결과'에만 적용한다는 라이라 프로젝트의 설계 사상을 다시 한번 체감할 수 있었다. 이 원칙을 명확히 인지하고 코드를 작성하면 앞으로 발생할 수 있는 수많은 네트워크 동기화 문제를 미연에 방지할 수 있을 것이다. 단순히 기능을 구현하는 개발을 넘어, 시스템의 근본적인 동작 원리를 파고드는 것의 중요성을 깨달았다.
