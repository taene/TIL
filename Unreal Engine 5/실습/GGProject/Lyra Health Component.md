# GE_HealthComponent

- ASC를 통해서 HealthSet에 접근할 수 있음
- ASC에 접근하는 이유 : HealtSet을 가져오기 위해 → HealthSet의 Health가 바뀔때마다 델리게이트로 알려주는 것을 ASC로 할 수 있다.

## HealthComponent 분석

- 게임 UI 시스템, 특히 체력(HP)과 같은 캐릭터 속성을 시각적으로 표현할 때 발생하는 고질적인 문제점과 이에 대한 고급 아키텍처 해결책을 분석한다.
- 전통적인 방식은 UI 요소가 캐릭터의 데이터를 매 프레임마다 확인(`Tick`)하거나 직접 참조하는 구조로, 이는 심각한 성능 저하와 시스템 간의 강한 종속성(Coupling)을 유발한다.
- 이 문제에 대한 해결책으로, 어트리뷰트(데이터)와 UI(표현) 사이에 `Health Component`라는 중개자를 두는 분리형 아키텍처를 제시한다.
- 이 컴포넌트는 `Tick`을 사용하지 않고, 대신 어빌리티 시스템의 델리게이트(Delegate)를 활용한 이벤트 기반 방식으로 동작한다. 속성 값이 변경될 때만 관련 시스템에 변경 사실을 통지(Broadcast)함으로써, 불필요한 연산을 제거하고 성능을 최적화한다.
1. **성능 최적화**: `Tick` 기반 폴링(Polling)을 제거하고 이벤트 기반 푸시(Push) 방식으로 전환하여 UI 업데이트로 인한 성능 부하를 원천적으로 차단한다.
2. **종속성 분리**: `Health Component`가 어트리뷰트와 UI 사이의 '브릿지' 역할을 수행하여 두 시스템이 서로를 직접 알 필요가 없게 만든다. 이로 인해 코드의 유연성과 재사용성이 크게 향상된다.
3. **안정적인 초기화**: `Pawn Extension Component`를 활용하여 어빌리티 시스템, 플레이어 스테이트, 폰 등 복잡한 요소들의 초기화가 모두 완료된 정확한 시점에 컴포넌트 간의 연결을 보장함으로써 시스템의 안정성을 확보한다.

---

## 1. 기존 UI 업데이트 방식의 문제점

전통적인 게임 UI 업데이트 방식은 구현이 직관적이지만 시스템이 복잡해질수록 심각한 한계에 부딪힌다. 주요 문제점은 성능 저하와 강한 종속성으로 요약된다.

### 1.1. 틱(Tick) 기반 업데이트의 성능 저하

가장 흔하고 손쉬운 방법은 UI 위젯이 매 프레임(`Tick`)마다 캐릭터의 체력 값을 확인하여 변경 사항이 있으면 화면을 갱신하는 것이다.

- **문제점**: 이 방식은 UI 요소가 한두 개일 때는 문제가 되지 않지만, 현대 게임처럼 수십 개의 UI 요소가 동시에 존재하는 환경에서는 치명적인 성능 저하를 유발한다.

모든 UI 요소가 매 프레임 데이터를 폴링(Polling)하는 것은 CPU 자원의 명백한 낭비이며, 게임의 전반적인 프레임률에 직접적인 악영향을 미친다.

### 1.2. 강한 종속성(Coupling)으로 인한 유지보수 난이도 증가

또 다른 일반적인 접근법은 UI와 캐릭터가 서로를 직접 참조하여 데이터를 주고받는 방식이다. 이는 시스템 간의 결합도를 극도로 높여 다음과 같은 문제를 야기한다.

- **스파게티 코드**: 시스템이 거대해지면 UI와 캐릭터의 여러 속성들이 거미줄처럼 얽히게 된다. 예를 들어, 30개의 스탯과 수많은 UI가 서로를 직접 참조하는 상황을 상상할 수 있다.
- **예측 불가능한 부작용**: 한 시스템의 작은 변경이 연관된 다른 시스템에 예상치 못한 오류를 발생시킨다. 캐릭터의 속성 로직을 수정했을 뿐인데 UI에서 에러가 발생하거나, UI 디자인을 변경했더니 캐릭터 로직에 문제가 생기는 경우가 빈번해진다.

이러한 강한 종속성은 코드의 재사용성을 저해하고, 디버깅을 어렵게 만들며, 장기적으로 프로젝트의 확장성을 심각하게 제한하는 주요 원인이 된다.

## 2. Lyra 프레임워크의 해결책: 헬스 컴포넌트

Lyra 프레임워크에서 제시하는 `Health Component`는 앞서 언급된 성능 및 종속성 문제를 해결하기 위한 정교한 아키텍처적 해법이다.

### 2.1. 아키텍처 개요

핵심 아이디어는 데이터 소스(어트리뷰트)와 데이터 소비자(UI)를 완전히 분리하는 것이다. 이를 위해 `Health Component`가 두 시스템 사이의 중개자(Mediator) 또는 브릿지(Bridge) 역할을 수행한다.

- **구조**: `Attribute Set (HealthSet)` ↔ `Health Component` ↔ `UI 위젯`
- **역할**:
    - **어트리뷰트 셋**: 실제 체력, 최대 체력 등의 데이터 값을 저장하고 관리한다.
    - **헬스 컴포넌트**: 어트리뷰트 셋의 값 변경을 감지하여, 자신에게 등록된 외부 시스템(UI 등)에 그 변경 사실을 전파한다.
    - **UI 위젯**: 헬스 컴포넌트에 자신의 업데이트 함수를 등록(Bind)하고, 변경 통지를 받을 때만 화면을 갱신한다.

이 구조를 통해 UI는 체력 데이터가 어디서 오는지 알 필요가 없으며, 어트리뷰트 시스템 역시 자신의 데이터가 UI에 표시되는지 알 필요가 없다. 양쪽 모두 오직 `Health Component`와만 통신한다.

### 2.2. 이벤트 기반(델리게이트) 통신 방식

이 아키텍처는 `Tick`을 완전히 배제하고, 이벤트 기반의 통신 모델을 채택한다.

- **동작 흐름**:
    1. 게임플레이 이펙트 등으로 인해 캐릭터의 `Health` 어트리뷰트 값이 변경된다.
    2. `ASC`는 내부적으로 이 값의 변경을 감지하고, 해당 어트리뷰트에 연결된 델리게이트를 호출한다.
    3. `Health Component`는 초기화 시점에 이 ASC의 델리게이트에 자신의 핸들러 함수(`HandleHealthChange`)를 등록해 두었으므로, 이 함수가 자동으로 호출된다.
    4. `HandleHealthChange` 함수는 전달받은 이전 값과 새 값을 사용하여 `Health Component` 자신이 소유한 `OnHealthChangeDelegate`라는 또 다른 델리게이트를 브로드캐스트한다.
    5. UI 위젯은 이 `OnHealthChangeDelegate`에 자신의 업데이트 함수를 등록해 두었기 때문에, 최종적으로 변경된 값을 전달받아 UI를 갱신한다.
- **핵심 장점**: 이 방식은 데이터가 **실제로 변경되었을 때만** 연산이 발생하므로 극도로 효율적이다.

## 3. 핵심 구현 상세

이 아키텍처를 성공적으로 구현하기 위한 몇 가지 핵심적인 기술적 세부 사항이 존재한다.

### 3.1. 헬스 컴포넌트

`Health Component`는 브릿지 역할을 수행하며, `Tick` 기능은 비활성화되어 있다. 가장 중요한 함수는 `InitializeWithAbilitySystem`이다.

- **초기화 로직 (`InitializeWithAbilitySystem`)**:
    1. `ASC`에 접근하여 `GetSet<UHealthSet>()` 함수를 통해 현재 캐릭터에 적용된 `HealthSet` 인스턴스를 가져온다. 이는 언리얼 엔진의 리플렉션(Reflection) 시스템 덕분에 가능하다.
    2. 가져온 `HealthSet`으로부터 `GetGameplayAttributeValueChangeDelegate(FGameplayAttribute)` 함수를 호출하여 'Health' 속성 값 변경을 알리는 전용 델리게이트를 얻는다.
    3. 이 델리게이트에 `Health Component` 내부의 핸들러 함수(`HandleHealthChange`)를 추가(`AddUObject`)한다.
    4. 이후 'Health' 속성이 변경될 때마다 등록된 핸들러가 호출되어 `Health Component`의 자체 델리게이트를 브로드캐스트하게 된다.

```cpp
HealthSet = AbilitySystemComponent->GetSet<ULyraHealthSet>();
```

- ASC::GetSet은 SpawendAttributes에서 가져온다.
    - 근데 PlayerState에서 Subobject로 생성하고 따로 ASC에 등록한적이 없는데 어떻게 등록되어있을까?
        - ASC::InitializeComonent()에서 GetObjectsWithOuter로 SpawnedAttributes에 추가된다. (자동추가)
        - HealthSet은 PlayerState에 Subobject로 있고, ASC 또한 PlayerState에 있다
        - → ASC에서 GetObjectsWithOuter로 HealthSet이 접근이 가능하다!

### 3.2. 초기화 시점 문제와 폰 익스텐션 컴포넌트

`Health Component`의 `InitializeWithAbilitySystem` 함수를 호출하는 시점은 매우 중요하다. 너무 이르면 필요한 시스템(ASC 등)이 준비되지 않았을 수 있다. 안정적인 초기화를 위해서는 다음 네 가지 조건이 모두 충족되어야 한다.

1. `ASC`의 완전한 초기화
2. `Player State`의 정상적인 설정
3. 캐릭터 `Pawn`에 대한 컨트롤러의 빙의(Possess) 완료
4. Lyra의 `Experience` 로딩 및 관련 설정 적용 완료
- **해결책**: 이 모든 조건을 만족하는 완벽한 시점을 제공하는 것이 바로 `Pawn Extension Component`이다. 이 컴포넌트는 Lyra 프레임워크의 초기화 과정을 총괄한다.
- **"Register and Call" 패턴**: `Pawn Extension Component`는 `OnAbilitySystemInitialized_RegisterAndCall`과 같은 델리게이트를 제공한다.
    - 만약 ASC 초기화가 완료되기 **전**에 이 함수에 델리게이트를 등록하면, 등록된 함수는 나중에 ASC 초기화가 완료되는 시점에 호출된다.
    - 만약 ASC 초기화가 완료된 **후**에 등록하면, 등록된 함수는 즉시 호출된다.
    - 이 패턴 덕분에 호출 순서에 대한 걱정 없이 안정적으로 초기화 로직을 연결할 수 있다.

### 3.3. UI 위젯 (W_HealthBar) 연동

UI 위젯은 `Health Component`의 델리게이트에 자신을 등록하고 해제하는 로직을 관리해야 한다. 특히 플레이어의 폰이 교체되는 상황(예: 리스폰)을 정확하게 처리하는 것이 중요하다.

- **연동 로직**:
    1. UI 위젯은 생성 시점에 `Player Controller`의 `OnPawnChanged` 델리게이트에 이벤트를 바인딩한다.
    2. 폰이 변경될 때마다(`OnPawnChanged` 이벤트 호출 시) 다음 작업이 순차적으로 실행된다.
        - **언바인드(Unbind)**: 만약 이전에 연결된 **구(Old) 폰**이 있다면, 해당 폰의 `Health Component`에 등록했던 델리게이트를 반드시 **제거(Unbind)**한다. 이를 통해 메모리 누수나 유효하지 않은 객체에 대한 호출을 방지한다.
        - **바인드(Bind)**: 새로 할당된 **신규(New) 폰**에서 `Health Component`를 찾는다. 컴포넌트가 존재하면, 해당 `Health Component`의 `OnHealthChangeDelegate`에 UI 업데이트를 수행할 이벤트를 **등록(Bind)**한다.

이 과정을 통해 UI는 항상 현재 플레이어가 조종하는 캐릭터의 체력 변화만을 정확하게 수신하고 반영할 수 있게 된다.

## 4. 결론

`Health Component`를 중심으로 설계된 아키텍처는 `Tick` 기반 업데이트와 강한 종속성이라는 전통적인 UI 개발 방식의 한계를 명확하게 극복한다. 시스템 간의 역할을 명확히 분리하고 이벤트 기반 통신을 채택함으로써, 성능, 유지보수성, 확장성 측면에서 월등한 이점을 제공한다.

특히 복잡한 초기화 순서를 `Pawn Extension Component`의 "Register and Call" 델리게이트 패턴으로 우아하게 해결한 점은 이 설계의 완성도를 높이는 핵심 요소이다. 이 구조를 이해하고 적용하는 것은 비단 체력 UI뿐만 아니라 게임 내 다양한 데이터 시각화 시스템을 견고하게 구축하는 데 있어 중요한 기반이 된다.
