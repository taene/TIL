## 학습 키워드

  * 3인칭 카메라 조준
  * 라인 트레이스 (Line Trace)
  * 목표 지점 보정
  * `Actors to Ignore`
  * `Select` 노드

<br/>

## 학습 내용

### 배운 개념 요약

3인칭 게임에서 발사체를 플레이어의 조준점(화면 중앙)으로 정확히 보내기 위한 목표 지점 계산 방법을 학습했다. 단순히 캐릭터의 손이나 총구 소켓의 Transform을 사용하면, 캐릭터의 애니메이션 방향으로 발사체가 나가기 때문에 플레이어의 시점과 일치하지 않는 문제가 발생한다.

이 문제를 해결하기 위해, 플레이어의 **카메라 위치에서 화면 중앙을 향해 라인 트레이스**를 쏘아 실제 월드에 부딪히는 지점을 '**진짜 목표 지점**'으로 설정한다. 이후 발사체는 캐릭터의 손에서 출발하되, 방향은 이 '진짜 목표 지점'을 향하도록 보정한다.

이 과정에서 라인 트레이스가 **시전자 자신에게 충돌하는 문제**가 발생할 수 있는데, 이는 `Line Trace By Channel` 노드의 **`Actors to Ignore`** 핀에 시전자 자신을 배열로 넘겨주어 해결한다. 또한, 트레이스의 성공 여부에 따라 목표 지점을 충돌 지점(`Impact Point`) 또는 트레이스의 끝 지점(`Trace End`)으로 선택해야 하는데, 이는 **`Select`** 노드를 사용하면 블루프린트 그래프를 매우 깔끔하고 효율적으로 구성할 수 있다.


<br/>


### 구현 과정

1.  **카메라 정보 획득 및 트레이스 경로 계산**: `Get Player Camera Manager`를 통해 카메라의 위치와 `Get Actor Forward Vector`로 전방 벡터를 얻는다. `(카메라 위치) + (전방 벡터 * 사거리)` 공식을 통해 라인 트레이스의 시작점과 끝점을 계산한다.

2.  **라인 트레이스 실행 (자기 자신 무시)**: `Line Trace By Channel` 노드를 호출한다. `Actors to Ignore` 핀에 `Make Array` 노드를 연결하고, `Get Avatar Actor from Actor Info` 노드로 얻어온 **캐릭터 자신**을 배열의 원소로 추가하여 트레이스가 시전자를 무시하도록 설정한다.

3.  **`Select` 노드를 이용한 목표 지점 결정**: `Select` 노드의 `Index` 핀에 라인 트레이션의 `Return Value`(bool)를 연결한다.

      * `True` 입력 핀에는 `Break Hit Result`로 분리한 `Impact Point`를 연결한다.
      * `False` 입력 핀에는 트레이스의 끝점인 `Trace End`를 연결한다.
      * `Select` 노드의 `Return Value`가 최종 **목표 지점**(Target Location)이 된다.

4.  **최종 발사 방향 계산**: 발사체의 시작점(캐릭터의 손 소켓 위치)과 방금 구한 **목표 지점**을 `Find Look At Rotation` 노드에 연결하여 최종 발사 방향을 계산한다.

5.  **발사체 스폰**: `Make Transform` 노드를 사용하여 발사 시작점의 위치(Location)와 새로 계산된 방향(Rotation)을 조합한 뒤, 이를 어빌리티 태스크의 `Spawn Transform` 값으로 사용하여 발사체를 스폰한다.


<br/>


## 느낀점

단순히 소켓 위치에서 발사하면 될 것이라고 생각했지만, 플레이어의 경험(UX) 관점에서는 조준점과 발사 궤적이 일치하는 것이 매우 중요하다는 것을 깨달았다. 카메라를 기준으로 한 라인 트레이스 방식은 애니메이션의 시각적 표현과 실제 게임플레이 로직을 분리하는 좋은 설계 방식임을 이해했다.

특히 라인 트레이스가 자기 자신을 맞추는 문제는 예상치 못한 버그였지만, `Actors to Ignore`라는 명확한 해결책이 존재한다는 것을 알게 되었다. `Branch` 대신 `Select` 노드를 사용하여 데이터의 흐름을 깔끔하게 처리하는 방법은 앞으로 블루프린트를 작성할 때 계속해서 활용해야 할 유용한 기술이다. 눈에 보이는 현상 이면의 논리적 문제를 파악하고 해결하는 과정에서 디버깅의 중요성을 다시 한번 느꼈다.
