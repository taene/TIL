## 학습 키워드
- GameFramework, GameMode, GameState, PlayerState, GameInstance
- 라이라(Lyra), 모듈화(Modularity), 데이터 중심 설계(Data-Driven Design)
- 게임플레이 어빌리티 시스템(GAS), 생명주기(Lifecycle), 네트워크 권한(Network Authority)

<br/>

## 학습 내용
### 배운 개념 요약
- **언리얼 엔진 게임 프레임워크 4대 클래스**의 역할과 책임에 대해 학습했다.
- 기본 개념을 넘어, AAA급 프로젝트 **라이라(Lyra)** 에서는 이 클래스들을 어떻게 활용하여 **모듈성, 확장성, 네트워크 안정성**을 확보하는지 심층적으로 이해했다.

<br/>

#### **프레임워크 클래스별 역할 비교**

| 클래스 | **기본 학습 내용 (네가 정리한 것)** | **라이라(Lyra) 관점 심화 (내가 설명한 것)** |
| :--- | :--- | :--- |
| **GameMode** | 게임의 **규칙, 흐름, 승패를 판정**하는 '심판'. 서버에만 존재하며, '결정'을 내리는 책임을 진다. | **가벼운 셸(Shell)이자 모듈의 허브.** 핵심 로직을 직접 갖기보다, '게임 피처 플러그인'을 통해 필요한 규칙(컴포넌트)을 동적으로 **주입**받는다. |
| **GameState** | 모든 플레이어가 보는 '공공 상황판'. **서버가 결정한 정보**를 저장하고 모든 클라이언트에 복제한다. UI는 이를 읽기만 한다. | **데이터 중심 설계의 중심축.** 단순 정보 저장을 넘어, **'게임 단계(Game Phase)'를 관리하고 브로드캐스트**하여 다른 시스템들이 독립적으로 반응하게 만든다. |
| **PlayerState** | 플레이어 개인의 '영속적인 신분증'. Pawn이 파괴되어도 유지되며, 점수나 이름 같은 개인 데이터를 가진다. | **라이라 아키텍처의 심장.** 플레이어의 능력/스킬을 관리하는 **게임플레이 어빌리티 시스템(GAS)의 `AbilitySystemComponent`를 소유**한다. 'Pawn'이라는 육체와 'PlayerState'라는 영혼을 분리하는 핵심 철학. |
| **GameInstance** | 게임 전체의 '총괄 관리자'. 게임 시작부터 종료까지 유지되며, 레벨 전환 시에도 데이터를 보존하고 관리한다. | **애플리케이션의 시작점.** 전반적인 서브시스템 초기화, 온라인 세션 관리, 메뉴와 게임 월드 간의 전환 등 **게임 프로그램 전체의 생명주기**를 책임진다. |

<br/>

### 구현 과정
- 프레임워크 클래스들의 **초기화 순서**가 매우 중요하며, 특히 `BeginPlay()`의 호출 순서는 보장되지 않아 위험하다는 것을 배웠다.
- 이를 해결하기 위해, 시나리오에 맞는 더 명확하고 **안전한 초기화 함수**를 사용하는 패턴을 익혔다.

#### **안전한 초기화 코드 패턴**

1.  **서버에서 플레이어 준비 완료 시점 보장: `PostLogin`**
    - `GameMode`에서 `PostLogin` 함수를 오버라이드하면, 플레이어의 `Controller`와 `PlayerState`가 모두 유효함을 보장받는 시점에서 초기화 로직을 실행할 수 있다.

2.  **클라이언트에서 데이터 복제 완료 시점 보장: `OnRep_`**
    - `Pawn`이나 `PlayerController`에서 `OnRep_PlayerState()`를 오버라이드하면, `BeginPlay`와 달리 클라이언트에 `PlayerState`가 성공적으로 복제된 직후 코드를 실행할 수 있어 `nullptr` 접근 위험이 없다.

```cpp
// MyCharacter.cpp - 클라이언트에서 PlayerState를 안전하게 참조하는 방법
void AMyCharacter::OnRep_PlayerState()
{
    // 이 함수가 호출된 시점은 PlayerState 포인터가 유효함을 100% 보장한다.
    Super::OnRep_PlayerState();

    // 이제 PlayerState에 안전하게 접근하여 UI를 초기화하거나,
    // AbilitySystemComponent를 가져와 어빌리티 관련 바인딩을 수행할 수 있다.
    if (AMyPlayerState* PS = GetPlayerState<AMyPlayerState>())
    {
        // 안전한 초기화 로직
    }
}
```
---

### 느낀점
- 게임 프레임워크는 단순히 클래스를 나눠놓은 것이 아니라, '데이터의 생명주기'와 '네트워크 권한' 이라는 명확한 철학을 기반으로 설계되었다는 것을 깨달았다.
- 특히 라이라의 설계는 '왜 그 데이터가 거기에 있어야 하는가?' 에 대한 깊은 고민의 결과물임을 알 수 있었다. PlayerState에 AbilitySystemComponent를 두는 이유가 가장 대표적이다.
- '싱글플레이어니까 대충'이라는 생각은 버려야 한다. 프레임워크 규칙에 맞춰 개발하는 습관 자체가 곧 멀티플레이어 환경에 대한 대비이자, 확장성 있는 아키텍처를 만드는 훈련이라는 것을 명심해야겠다.
- BeginPlay의 함정을 피하고 PostLogin, OnRep_ 같은 명확한 시점을 사용하는 것이 프로와 아마추어의 코드 안정성을 가르는 중요한 차이점 중 하나임을 배웠다.
