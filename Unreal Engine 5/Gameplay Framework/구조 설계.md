## 학습 키워드 

- 시스템 설계
- 요구사항 분석
- 기능 분해
- 클래스 설계
- 추상화
- 데이터 중심 설계

<br/>

## 학습 내용

### 배운 개념 요약 

코드를 작성하기 전, 시스템의 구조를 먼저 설계하는 방법에 대해 학습했다. 이는 재작업을 줄이고, 협업을 용이하게 하며, 확장성 있는 코드를 작성하기 위한 필수적인 과정이다. 집을 짓기 전 설계도를 그리는 것과 같은 원리이다.

시스템 설계는 다음과 같은 6단계의 체계적인 과정을 통해 이루어진다.

1.  **요구사항 정의 및 분석:** 만들고자 하는 기능의 목표와 범위를 명확히 정의한다. "무엇을 만들 것인가?"에 대한 구체적인 기능 목록을 작성하는 단계이다.
2.  **기능 분해:** 정의된 큰 기능을 구현 가능한 작은 단위의 기능으로 나눈다.
3.  **핵심 클래스 설계:** 분해된 기능 조각들을 언리얼 엔진의 어떤 클래스(데이터, 기능, 표현)로 구현할지 결정한다. Lyra의 데이터 중심 설계 철학에 따라 데이터(`UPrimaryDataAsset`, `UObject`), 기능(`UActorComponent`), 월드 상의 사물(`AActor`), UI(`UUserWidget`) 등으로 역할을 분리한다.
4.  **상호작용 정의:** 설계된 클래스들이 서로 어떻게 정보를 주고받고 함수를 호출하는지, 데이터의 흐름을 정의한다.
5.  **세부 구현 계획:** 각 클래스에 필요한 구체적인 변수와 함수를 상세하게 설계한다. 헤더 파일에 들어갈 내용을 미리 구상하는 단계이다.
6.  **개선 및 확장 계획:** 프로토타입 구현 이후의 최적화, 기능 확장, 로직 개선점 등을 미리 계획하여 더 견고하고 유연한 시스템을 대비한다.

<br/>

### 구현 과정 

학습한 설계 과정을 가상의 '보호막(Shield)' 기능에 적용하여 설계 과정을 연습했다.

1.  **요구사항 정의:**

      * 플레이어는 보호막 스킬을 사용할 수 있다.
      * 활성화된 보호막은 체력보다 먼저 피해를 흡수한다.
      * 보호막은 시간이 지나면 자동으로 회복된다.
      * 보호막이 파괴되면 일정 시간 재사용할 수 없다.

2.  **기능 분해:**

      * 보호막 수치 데이터 관리 (현재 보호막, 최대 보호막, 회복률)
      * 보호막 활성화/비활성화 로직
      * 피해 흡수 로직
      * 보호막 자동 회복 로직
      * 보호막 파괴 및 재사용 대기 상태 관리
      * 보호막 UI 시각화

3.  **핵심 클래스 설계 (Lyra 아키텍처 기반):**

      * **`UAttributeSet`:** `Shield`, `MaxShield`, `ShieldRegenRate` 같은 '데이터'를 속성으로 정의한다.
      * **`UGameplayAbility`:** '보호막 활성화'라는 '스킬' 자체를 정의한다. 이 어빌리티는 사용자에게 `State.Shielded` 같은 게임플레이 태그를 부여하는 역할을 한다.
      * **`UGameplayEffect`:** 보호막의 '효과'를 정의한다. 주기적인 보호막 회복 효과, 또는 보호막이 깨졌을 때 어빌리티 사용을 막는 재사용 대기 효과 등을 구현한다.
      * **`UGameplayEffectExecutionCalculation`:** 데미지 계산 로직을 담당한다. 피해를 최종 적용하기 전에 대상이 `State.Shielded` 태그를 가지고 있는지 확인하고, `Shield` 속성부터 차감하도록 구현한다.
      * **`UUserWidget`:** `UAttributeSet`의 `Shield`, `MaxShield` 값을 받아 UI에 시각적으로 '표현'한다.

4.  **상호작용 정의:**

      * 플레이어가 `UGameplayAbility`를 실행한다.
      * 어빌리티는 대상에게 `State.Shielded` 태그와 함께 주기적인 회복 `UGameplayEffect`를 적용한다.
      * 피해를 받으면, 데미지 계산 `ExecutionCalculation`이 `State.Shielded` 태그를 확인하고 `Shield` 속성을 먼저 차감한다.
      * `Shield`가 0이 되면 `State.Shielded` 태그를 제거하고, 재사용 대기 `UGameplayEffect`와 태그를 부여한다.
      * UI 위젯은 `Shield` 속성의 변경을 감지하여 실시간으로 바(Bar)의 형태를 업데이트한다.

<br/>

## 느낀점 

지금까지는 기능을 구현할 때 일단 코드를 작성하며 부딪히는 방식으로 개발을 진행했다. 하지만 이런 방식은 기능이 복잡해질수록 구조가 꼬이고, 새로운 기능을 추가하거나 기존 기능을 수정할 때 많은 어려움을 겪게 만드는 원인이었다.

시스템을 설계하는 것은 단순히 코딩을 시작하기 전의 추가적인 작업이 아니라, 전체 개발의 방향을 결정하는 설계도를 그리는 과정이라는 것을 깨달았다. 특히 기능을 데이터, 로직, 표현으로 분리하여 생각하고, 이를 언리얼 엔진과 Lyra의 철학에 맞는 클래스로 설계하는 과정은 코드의 재사용성과 확장성을 크게 높여줄 수 있음을 이해했다.

처음에는 이 과정이 낯설고 시간이 더 걸리는 것처럼 느껴지겠지만, 의식적으로 반복하여 훈련해야겠다. 작은 기능이라도 6단계 설계 과정을 거치는 연습을 통해, 코드를 작성하는 '코더'를 넘어 시스템을 구축하는 '엔지니어'로 성장하는 기반을 다져야겠다.
